com.liang.BootstrapApplication.main()
    --> SpringApplication.run(BootstrapApplication.class,args);
        --> ConfigurableApplicationContext context = run(new Class<?>[] { primarySource }, args);
            --> return run(new Class<?>[] { primarySource }, args);
                --> SpringApplication springApplication = new SpringApplication(primarySources);
                    --> this(null, primarySources);
                            //设置resourceLoader，这里为null
                        --> this.resourceLoader = resourceLoader;
                            //设置启动的主类
                        --> this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources)); // class com.liang.BootstrapApplication
                            //设置容器类型
                        --> this.webApplicationType = WebApplicationType.deduceFromClasspath();
                            --> return WebApplicationType.SERVLET;

                            //根据ApplicationContextInitializer.class加载jar包中spring.facotries默认的key为根据org.springframework.context.ApplicationContextInitializer的配置，可能不同的jar包维护的数据不同，然后进行实例化，所以加载出来的是个list
                        --> <T> Collection<T> initializers = (Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)
                            --> return getSpringFactoriesInstances(type, new Class<?>[] {});
                                    //获取默认的classLoader
                                --> ClassLoader classLoader = getClassLoader();
                                    --> return ClassUtils.getDefaultClassLoader();
                                        --> ClassLoader cl = Thread.currentThread().getContextClassLoader();
                                        --> return cl;

                                    //解析spring.facotries文件，加载所有jar包中默认的配置类的名称为ApplicationContextInitializer对应的类，放到list中
                                --> List<String> list = SpringFactoriesLoader.loadFactoryNames(type, classLoader);
                                    --> org.springframework.core.io.support.SpringFactoriesLoader.loadFactoryNames(Class<?> factoryClass,ClassLoader classLoader);
                                        --> String factoryClassName = factoryClass.getName(); //org.springframework.context.ApplicationContextInitializer
                                        --> Map<String, List<String>> map = loadSpringFactories(classLoader);

                                            --> MultiValueMap<String, String> result = new LinkedMultiValueMap<>();

                                            --> Enumeration<URL> urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));
                                                --> Enumeration<URL>[] tmp = (Enumeration<URL>[]) new Enumeration<?>[2];
                                                    //从spring.factory文件中读取固定的一些基本配置类
                                                --> tmp[0] = getBootstrapResources(name); //META-INF/spring.factories
                                                    --> java.lang.ClassLoader.getBootstrapResources("META-INF/spring.factories")
                                                        --> final Enumeration<Resource> e = getBootstrapClassPath().getResources(name);
                                                            --> return sun.misc.Launcher.getBootstrapClassPath()
                                                        --> return new Enumeration<URL> () {
                                                                        public URL nextElement() {
                                                                            return e.nextElement().getURL();
                                                                        }
                                                                        public boolean hasMoreElements() {
                                                                            return e.hasMoreElements();
                                                                        }
                                                                    }

                                                --> tmp[1] = parent.getResources(name); //META-INF/spring.factories
                                                    --> return java.util.Collections.emptyEnumeration();

                                                --> return new CompoundEnumeration<>(tmp);

                                            --> while (urls.hasMoreElements())
                                                    // url就是jar:file:/Users/liang/tool/maven%20repo/org/springframework/boot/spring-boot/2.1.1.RELEASE/spring-boot-2.1.1.RELEASE.jar!/META-INF/spring.factories文件
                                                --> URL url = urls.nextElement();
                                                --> UrlResource resource = new UrlResource(url);
                                                    // 从文件中读取配置文件
                                                --> Properties properties = PropertiesLoaderUtils.loadProperties(resource);
                                                    //循环properties，把里面的factoryClassName都拿出来，放到result里面
                                                --> String factoryClassName = ((String) entry.getKey()).trim();
                                                --> result.add(factoryClassName, factoryName.trim());

                                            --> cache.put(classLoader, result);
                                                //result里面存放的是key-list那种取得的类
                                            --> return result;

                                        --> return map.getOrDefault(factoryClassName, Collections.emptyList());

                                    //将加载出来的factoryClassName进行去重
                                --> Set<String> names = new LinkedHashSet<>(list);

                                    //将读取出来的factoryClassName进行实例化，就会出现各种factory
                                --> List<T> instances = createSpringFactoriesInstances(type, parameterTypes,classLoader, args, names); //type = interface org.springframework.context.ApplicationContextInitializer; names = {org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,org.springframework.boot.context.ContextIdApplicationContextInitializer,org.springframework.boot.context.config.DelegatingApplicationContextInitializer,org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer,org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener}
                                    --> List<T> instances = new ArrayList<>(names.size());
                                    --> for (String name : names)
                                        --> Class<?> instanceClass = ClassUtils.forName(name, classLoader);
                                        --> T instance = (T) BeanUtils.instantiateClass(constructor, args);
                                                //用反射将构造函数弄成可见的状态
                                            --> ReflectionUtils.makeAccessible(ctor);
                                                //执行初始化
                                            --> return ctor.newInstance(args)

                                        --> instances.add(instance);

                                    --> return instances;

                                --> AnnotationAwareOrderComparator.sort(instances);
                                        // 如果实现了Ordered接口就能排序
                                    --> org.springframework.core.OrderComparator.compare(@Nullable Object o1, @Nullable Object o)
                                        --> return doCompare(o1, o2, null);
                                            --> findOrder(Object obj)
                                                --> (Ordered) obj).getOrder()

                                --> return instances;

                            //对SpringApplication的initializers属性进行初始化
                        --> setInitializers(initializers);
                            --> SpringApplication.initializers.addAll(initializers);

                            //从//META-INF/spring.factories获取所有的ApplicationListener接口得实现类
                        --> Collection listeners = (Collection) getSpringFactoriesInstances(ApplicationListener.class);
                            --> 过程和上面初始化initializers相同，只不过读取的类不同

                        --> setListeners(listeners);
                            --> SpringApplication.listeners.addAll(listeners);

                        --> this.mainApplicationClass = deduceMainApplicationClass();

                    //加载完一些基本类，监听类，现在开始运行
                --> return springApplication.run(args);
                    --> ConfigurableApplicationContext context = null;
                    --> configureHeadlessProperty();
                            //java.awt.headless是J2SE的一种模式，用于在缺失显示屏、鼠标或者键盘时的系统配置。对于后端服务来讲，很多都是需要将这个属性设置为true的。
                        --> System.setProperty("java.awt.headless", System.getProperty("java.awt.headless", Boolean.toString(this.headless)));

                        //从配置文件中读取一些默认的监听器
                    --> SpringApplicationRunListeners listeners = SpringApplication.getRunListeners(args);
                        --> Class<?>[] types = new Class<?>[] { SpringApplication.class, String[].class };

                        --> Collection runListeners = getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args); // org.springframework.boot.context.event.EventPublishingRunListener
                            --> 这里加载SpringApplicationRunListener实现类的方法和之前的是一样的

                        --> return new SpringApplicationRunListeners(logger, runListeners);
                            --> org.springframework.boot.SpringApplicationRunListeners
                                --> this.log = log;
                                --> this.listeners = new ArrayList<>(listeners);
                        //启动监听器链
                    --> listeners.starting();
                        --> org.springframework.boot.SpringApplicationRunListeners.starting()
                            --> for (SpringApplicationRunListener listener : this.listeners)
                                --> listener.starting();
                                        //系统中默认添加了个EventPublishingRunListener
                                    --> org.springframework.boot.context.event.EventPublishingRunListener.starting()
                                        --> ApplicationStartingEvent event = new ApplicationStartingEvent(this.application, this.args)
                                            --> org.springframework.boot.context.event.SpringApplicationEvent.SpringApplicationEvent(SpringApplication application, String[] args)
                                                --> org.springframework.context.ApplicationEvent.ApplicationEvent((Object application))
                                                    --> this.source = source;
                                                --> this.args = args;

                                        --> this.initialMulticaster.multicastEvent(event);
                                            --> org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(org.springframework.context.ApplicationEvent)
                                                --> ResolvableType resolvableType = resolveDefaultEventType(event)
                                                    --> org.springframework.context.event.SimpleApplicationEventMulticaster.resolveDefaultEventType(ApplicationEvent event)
                                                        --> return ResolvableType.forInstance(event);
                                                            --> return ResolvableType.forClass(instance.getClass());
                                                                --> return new ResolvableType(clazz);
                                                                    --> this.resolved = (clazz != null ? clazz : Object.class); //class org.springframework.boot.context.event.ApplicationStartingEvent
                                                                    --> this.type = this.resolved; // class org.springframework.boot.context.event.ApplicationStartingEvent
                                                                    --> this.typeProvider = null;
                                                                    --> this.variableResolver = null;
                                                                    --> this.componentType = null;
                                                                    --> this.hash = null;

                                                --> multicastEvent(event, resolvableType);
                                                        //如果resolvableType是空，就再执行上面的步骤，此处不是空
                                                    --> ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));
                                                    --> List<ApplicationListener> listeners = getApplicationListeners(event, type) //event = org.springframework.boot.context.event.ApplicationStartingEvent[source=org.springframework.boot.SpringApplication@247bddad]
                                                        --> Object source = event.getSource(); // org.springframework.boot.SpringApplication@247bddad
                                                        --> Class<?> sourceType = (source != null ? source.getClass() : null); // class org.springframework.boot.SpringApplication
                                                        --> ListenerCacheKey cacheKey = new ListenerCacheKey(eventType, sourceType);
                                                            --> org.springframework.context.event.AbstractApplicationEventMulticaster.ListenerCacheKey.ListenerCacheKey
                                                                --> this.eventType = eventType;  //org.springframework.boot.context.event.ApplicationStartingEvent
                                                                --> this.sourceType = sourceType; // class org.springframework.boot.SpringApplication

                                                        --> ListenerRetriever retriever = this.retrieverCache.get(cacheKey);
                                                        --> retriever = new ListenerRetriever(true);
                                                            --> org.springframework.context.event.AbstractApplicationEventMulticaster.ListenerRetriever.ListenerRetriever
                                                                --> this.preFiltered = preFiltered; // true
                                                        --> Collection<ApplicationListener<?>> listeners = retrieveApplicationListeners(eventType, sourceType, retriever);
                                                            --> org.springframework.context.event.AbstractApplicationEventMulticaster.retrieveApplicationListeners(eventType, sourceType, retriever)
                                                                --> List<ApplicationListener<?>> allListeners = new ArrayList<>();
                                                                --> Set<ApplicationListener<?>> listeners = new LinkedHashSet<>(this.defaultRetriever.applicationListeners); //就是之前读出来的一堆listener
                                                                --> Set<String> listenerBeans = new LinkedHashSet<>(this.defaultRetriever.applicationListenerBeans);
                                                                --> for (ApplicationListener<?> listener : listeners)
                                                                    --> if (supportsEvent(listener, eventType, sourceType)
                                                                        --> listener instanceof GenericApplicationListener
                                                                        --> allListeners.add(listener) // 循环完毕之后原来13个监听器就剩下4个了，LoggingApplicationListener,BackgroundPreinitializer,DelegatingApplicationListener,LiquibaseServiceLocatorApplicationListener
                                                                --> return allListeners;

                                                        --> return listeners;

                                                        //循环调用刚才剩下的4个listener
                                                    --> for (final ApplicationListener<?> listener : listeners)
                                                            //如果executor不为空，就用executor多线程执行invokeListener方法，如果是空，就直接调用invokeListener方法
                                                        --> Executor executor = getTaskExecutor(); // null
                                                        --> invokeListener(listener, event);
                                                            --> ErrorHandler errorHandler = getErrorHandler(); // null
                                                            --> doInvokeListener(listener, event);
                                                                --> listener.onApplicationEvent(event);

                        //设置通过命令传进来的参数
                    --> ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
                        --> org.springframework.boot.DefaultApplicationArguments.DefaultApplicationArguments
                            --> this.source = new Source(args);
                                --> org.springframework.core.env.SimpleCommandLinePropertySource.SimpleCommandLinePropertySource(java.lang.String...)
                                    --> org.springframework.core.env.SimpleCommandLineArgsParser.parse(java.lang.String...)
                                            //这一步会将main方法传过来的一些参数进行解析，里面解析了类似于 --spring.profile.active=dev这种参数
                                        --> CommandLineArgs commandLineArgs = new CommandLineArgs();
                                        --> return commandLineArgs;
                            --> this.args = args;

                        //创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）。
                    --> ConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments);
                        --> ConfigurableEnvironment environment = getOrCreateEnvironment();
                            --> return new StandardServletEnvironment();

                        --> configureEnvironment(environment, applicationArguments.getSourceArgs());
                                //这是个类型转换器
                            --> ConversionService conversionService = ApplicationConversionService.getSharedInstance();
                                --> org.springframework.boot.convert.ApplicationConversionService.getSharedInstance()
                                    --> ApplicationConversionService sharedInstance = ApplicationConversionService.sharedInstance;
                                    --> sharedInstance = new ApplicationConversionService();
                                        --> public ApplicationConversionService()
                                            --> configure(this);
                                                --> DefaultConversionService.addDefaultConverters(registry);
                                                    --> addScalarConverters(converterRegistry);
                                                        --> converterRegistry.addConverterFactory(new NumberToNumberConverterFactory());

                                                            converterRegistry.addConverterFactory(new StringToNumberConverterFactory());
                                                            converterRegistry.addConverter(Number.class, String.class, new ObjectToStringConverter());

                                                            converterRegistry.addConverter(new StringToCharacterConverter());
                                                            converterRegistry.addConverter(Character.class, String.class, new ObjectToStringConverter());

                                                            converterRegistry.addConverter(new NumberToCharacterConverter());
                                                            converterRegistry.addConverterFactory(new CharacterToNumberFactory());

                                                            converterRegistry.addConverter(new StringToBooleanConverter());
                                                            converterRegistry.addConverter(Boolean.class, String.class, new ObjectToStringConverter());

                                                            converterRegistry.addConverterFactory(new StringToEnumConverterFactory());
                                                            converterRegistry.addConverter(new EnumToStringConverter((ConversionService) converterRegistry));

                                                            converterRegistry.addConverterFactory(new IntegerToEnumConverterFactory());
                                                            converterRegistry.addConverter(new EnumToIntegerConverter((ConversionService) converterRegistry));

                                                            converterRegistry.addConverter(new StringToLocaleConverter());
                                                            converterRegistry.addConverter(Locale.class, String.class, new ObjectToStringConverter());

                                                            converterRegistry.addConverter(new StringToCharsetConverter());
                                                            converterRegistry.addConverter(Charset.class, String.class, new ObjectToStringConverter());

                                                            converterRegistry.addConverter(new StringToCurrencyConverter());
                                                            converterRegistry.addConverter(Currency.class, String.class, new ObjectToStringConverter());

                                                            converterRegistry.addConverter(new StringToPropertiesConverter());
                                                            converterRegistry.addConverter(new PropertiesToStringConverter());

                                                            converterRegistry.addConverter(new StringToUUIDConverter());
                                                            converterRegistry.addConverter(UUID.class, String.class, new ObjectToStringConverter());
                                                            converterRegistry.addConverter(UUID.class, String.class, new ObjectToStringConverter());

                                                        addCollectionConverters(converterRegistry);
                                                        --> ConversionService conversionService = (ConversionService) converterRegistry;

                                                            converterRegistry.addConverter(new ArrayToCollectionConverter(conversionService));
                                                            converterRegistry.addConverter(new CollectionToArrayConverter(conversionService));

                                                            converterRegistry.addConverter(new ArrayToArrayConverter(conversionService));
                                                            converterRegistry.addConverter(new CollectionToCollectionConverter(conversionService));
                                                            converterRegistry.addConverter(new MapToMapConverter(conversionService));

                                                            converterRegistry.addConverter(new ArrayToStringConverter(conversionService));
                                                            converterRegistry.addConverter(new StringToArrayConverter(conversionService));

                                                            converterRegistry.addConverter(new ArrayToObjectConverter(conversionService));
                                                            converterRegistry.addConverter(new ObjectToArrayConverter(conversionService));

                                                            converterRegistry.addConverter(new CollectionToStringConverter(conversionService));
                                                            converterRegistry.addConverter(new StringToCollectionConverter(conversionService));

                                                            converterRegistry.addConverter(new CollectionToObjectConverter(conversionService));
                                                            converterRegistry.addConverter(new ObjectToCollectionConverter(conversionService));

                                                            converterRegistry.addConverter(new StreamConverter(conversionService));

                                                        converterRegistry.addConverter(new ByteBufferConverter((ConversionService) converterRegistry));
                                                        converterRegistry.addConverter(new StringToTimeZoneConverter());
                                                        converterRegistry.addConverter(new ZoneIdToTimeZoneConverter());
                                                        converterRegistry.addConverter(new ZonedDateTimeToCalendarConverter());

                                                        converterRegistry.addConverter(new ObjectToObjectConverter());
                                                        converterRegistry.addConverter(new IdToEntityConverter((ConversionService) converterRegistry));
                                                        converterRegistry.addConverter(new FallbackObjectToStringConverter());
                                                        converterRegistry.addConverter(new ObjectToOptionalConverter((ConversionService) converterRegistry));
                                                        converterRegistry.addConverter(new ObjectToOptionalConverter((ConversionService) converterRegistry));

                                                --> DefaultFormattingConversionService.addDefaultFormatters(registry);
                                                    --> formatterRegistry.addFormatterForFieldAnnotation(new NumberFormatAnnotationFormatterFactory());
                                                        new DateTimeFormatterRegistrar().registerFormatters(formatterRegistry);
                                                        new DateFormatterRegistrar().registerFormatters(formatterRegistry);

                                                --> addApplicationFormatters(registry);
                                                    --> registry.addFormatter(new CharArrayFormatter());
                                                        registry.addFormatter(new InetAddressFormatter());
                                                        registry.addFormatter(new IsoOffsetFormatter());

                                                --> addApplicationConverters(registry);
                                                    --> addDelimitedStringConverters(registry);
                                                        --> registry.addConverter(new ArrayToDelimitedStringConverter(service));
                                                            registry.addConverter(new CollectionToDelimitedStringConverter(service));
                                                            registry.addConverter(new DelimitedStringToArrayConverter(service));
                                                            registry.addConverter(new DelimitedStringToCollectionConverter(service));
                                                        registry.addConverter(new StringToDurationConverter());
                                                        registry.addConverter(new DurationToStringConverter());
                                                        registry.addConverter(new NumberToDurationConverter());
                                                        registry.addConverter(new DurationToNumberConverter());
                                                        registry.addConverter(new StringToDataSizeConverter());
                                                        registry.addConverter(new NumberToDataSizeConverter());
                                                        registry.addConverterFactory(new StringToEnumIgnoringCaseConverterFactory());

                                    --> return sharedInstance;

                            --> environment.setConversionService((ConfigurableConversionService) conversionService);
                                --> org.springframework.core.env.AbstractEnvironment.setConversionService(ConfigurableConversionService conversionService)
                                    --> this.propertyResolver.setConversionService(conversionService);
                                        --> org.springframework.core.env.AbstractPropertyResolver.setConversionService
                                            --> this.conversionService = conversionService;

                                //这一步是将从commandLineProperties解析出来的参数加到environment中，这个例子里面没有命令行参数
                            --> configurePropertySources(environment, args);
                                --> MutablePropertySources sources = environment.getPropertySources(); //初始化的时候servlet那个已经放了4个属性到properties里面，[StubPropertySource {name='servletConfigInitParams'}, StubPropertySource {name='servletContextInitParams'}, MapPropertySource {name='systemProperties'}, SystemEnvironmentPropertySource {name='systemEnvironment'}]

                                //设置配置文件的环境，哪个配置文件被激活
                            --> configureProfiles(environment, args);
                                    // ensure they are initialized
                                --> environment.getActiveProfiles();
                                    --> org.springframework.core.env.AbstractEnvironment.getActiveProfiles
                                        --> return StringUtils.toStringArray(doGetActiveProfiles());
                                                //可以带逗号，会通过逗号进行分割，变成数组，赋值给activeProfiles
                                            --> String profiles = getProperty("spring.profiles.active");
                                            --> setActiveProfiles(StringUtils.commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(profiles)));
                                            --> return this.activeProfiles;

                                --> Set<String> profiles = new LinkedHashSet<>(this.additionalProfiles);
                                --> profiles.addAll(Arrays.asList(environment.getActiveProfiles()));
                                --> environment.setActiveProfiles(StringUtils.toStringArray(profiles));
                                    --> org.springframework.core.env.AbstractEnvironment.setActiveProfiles
                                        --> this.activeProfiles.add(profile);


                        --> listeners.environmentPrepared(environment);
                            --> org.springframework.boot.SpringApplicationRunListeners.environmentPrepared
                                --> for (SpringApplicationRunListener listener : this.listeners) // EventPublishingRunListener,默认的只有一个
                                    --> listener.environmentPrepared(environment);
                                        --> org.springframework.boot.context.event.EventPublishingRunListener.environmentPrepared
                                            --> ApplicationEnvironmentPreparedEvent applicationEnvironmentPreparedEvent = new ApplicationEnvironmentPreparedEvent(this.application, this.args, environment);
                                                --> super(application, args);
                                                    --> this.args = args;
                                                    --> this.application = application;
                                                --> this.environment = environment;

                                            --> this.initialMulticaster.multicastEvent(applicationEnvironmentPreparedEvent);
                                                --> org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(org.springframework.context.ApplicationEvent)
                                                    --> multicastEvent(event, resolveDefaultEventType(event)); //event = org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent[source=org.springframework.boot.SpringApplication@247bddad];eventType = org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent
                                                        --> 里面有9个listener，剩下的解析和上面解析listener.starting()调用listener的过程一样,只不过加载的类不一样

                        --> bindToSpringApplication(environment);
                            --> Bind binder = Binder.get(environment);
                                --> org.springframework.boot.context.properties.bind.Binder.get(environment)
                                    --> Iterable<ConfigurationPropertySource> configurationPropertySources = ConfigurationPropertySources.get(environment);
                                        --> org.springframework.boot.context.properties.source.ConfigurationPropertySources.get(environment)
                                            --> MutablePropertySources sources = ((ConfigurableEnvironment) environment).getPropertySources();
                                            --> ConfigurationPropertySourcesPropertySource attached = (ConfigurationPropertySourcesPropertySource) sources.get("configurationProperties");
                                            --> return attached.getSource();

                                    --> PlaceholdersResolver placeholdersResolver = new PropertySourcesPlaceholdersResolver(environment);
                                        --> org.springframework.boot.context.properties.bind.PropertySourcesPlaceholdersResolver
                                            --> this(getSources(environment), null);
                                                --> this.sources = sources;
                                                --> this.helper = new PropertyPlaceholderHelper("${","}",":", true);
                                                    --> org.springframework.util.PropertyPlaceholderHelper.PropertyPlaceholderHelper(java.lang.String, java.lang.String, java.lang.String, boolean)
                                                        --> this.placeholderPrefix = placeholderPrefix; // ${
                                                        --> this.placeholderSuffix = placeholderSuffix; //}
                                                        --> String simplePrefixForSuffix = wellKnownSimplePrefixes.get(this.placeholderSuffix); //"{"
                                                        --> this.simplePrefix = simplePrefixForSuffix;
                                                        --> this.valueSeparator = valueSeparator; //:
                                                        --> this.ignoreUnresolvablePlaceholders = ignoreUnresolvablePlaceholders; //true

                                    --> return new Binder(configurationPropertySources,placeholdersResolver);
                                        --> org.springframework.boot.context.properties.bind.Binder.Binder(java.lang.Iterable<org.springframework.boot.context.properties.source.ConfigurationPropertySource>, org.springframework.boot.context.properties.bind.PlaceholdersResolver)
                                            --> this(sources, placeholdersResolver, null, null);
                                                --> this.sources = sources; //SpringConfigurationPropertySources
                                                --> this.placeholdersResolver = placeholdersResolver; //PropertySourcesPlaceholdersResolver
                                                --> this.conversionService = ApplicationConversionService.getSharedInstance();
                                                        //这一步在之前已经初始化过了，就是设置一堆converter的那个地方
                                                    --> ApplicationConversionService sharedInstance = ApplicationConversionService.sharedInstance;
                                                    --> return sharedInstance;
                                                --> this.propertyEditorInitializer = propertyEditorInitializer; // null

                            --> Bindable target = Bindable.ofInstance(this) //this 就是上面的SpringApplication.class的实例对象
                                --> Class<T> type = (Class<T>) instance.getClass();
                                --> Bindable bindable = of(type)
                                    --> org.springframework.boot.context.properties.bind.Bindable.of(org.springframework.core.ResolvableType)
                                        --> return of(ResolvableType.forClass(type));
                                            --> return new ResolvableType(clazz);
                                                --> this.resolved = (clazz != null ? clazz : Object.class);
                                                    this.type = this.resolved;
                                                    this.typeProvider = null;
                                                    this.variableResolver = null;
                                                    this.componentType = null;
                                                    this.hash = null;
                                            --> ResolvableType boxedType = box(type);
                                                --> Class<?> resolved = type.resolve();
                                                --> return type; // org.springframework.boot.SpringApplication

                                            --> return new Bindable<>(type, boxedType, null, NO_ANNOTATIONS);
                                                --> org.springframework.boot.context.properties.bind.Bindable.Bindable
                                                    --> this.type = type; //org.springframework.boot.SpringApplication
                                                        this.boxedType = boxedType; //org.springframework.boot.SpringApplication
                                                        this.value = value; // null
                                                        this.annotations = annotations; //{}

                                --> return bindable.withExistingValue(instance);
                                    --> Supplier<T> value = (existingValue != null) ? () -> existingValue : null; // 就是instance
                                    --> return new Bindable<>(this.type, this.boxedType, value, NO_ANNOTATIONS);
                                        --> this.type = type; // org.springframework.boot.SpringApplication
                                            this.boxedType = boxedType; // org.springframework.boot.SpringApplication
                                            this.value = value; //
                                            this.annotations = annotations; // {}


                            --> binder.bind("spring.main", target);
                                --> org.springframework.boot.context.properties.bind.Binder.bind(java.lang.String, org.springframework.boot.context.properties.bind.Bindable<T>)
                                    --> ConfigurationPropertyName configurationPropertyName = ConfigurationPropertyName.of(name);
                                        --> org.springframework.boot.context.properties.source.ConfigurationPropertyName.of(java.lang.CharSequence)
                                            --> Elements elements = new ElementsParser(name, '.').parse();
                                            --> return new ConfigurationPropertyName(elements);
                                                --> this.elements = elements;
                                                    this.uniformElements = new CharSequence[elements.getSize()];

                                    --> return bind(configurationPropertyName, target, null);
                                        --> handler = (handler != null) ? handler : new BindHandler();

                                        --> Context context = new org.springframework.boot.context.properties.bind.Binder.Context();
                                        --> T bound = bind(name, target, handler, context, false);
                                            --> target = handler.onStart(name, target, context);
                                                --> return target;
                                            --> Object bound = bindObject(name, target, handler, context,allowRecursiveBinding);
                                                --> ConfigurationProperty property = findProperty(name, context);
                                                    --> ConfigurationProperty property = source.getConfigurationProperty(name);
                                                    --> return null;

                                                --> AggregateBinder<?> aggregateBinder = getAggregateBinder(target, context);
                                                    --> Class<?> resolvedType = target.getType().resolve(Object.class); // class org.springframework.boot.SpringApplication
                                                    --> return null;

                                                --> return bindBean(name, target, handler, context, allowRecursiveBinding);
                                                    --> BeanPropertyBinder propertyBinder = (propertyName, propertyTarget) -> bind(name.append(propertyName), propertyTarget, handler, context, false);

                                                    --> Class<?> type = target.getType().resolve(Object.class); // class org.springframework.boot.SpringApplication

                                                    --> return context.withBean(type, () -> {
                                                        			Stream<?> boundBeans = BEAN_BINDERS.stream()
                                                        					.map((b) -> b.bind(name, target, context, propertyBinder));
                                                        			return boundBeans.filter(Objects::nonNull).findFirst().orElse(null);
                                                        		});
                                                        --> return withIncreasedDepth(supplier);
                                                            --> return supplier.get();

                                                        --> org.springframework.boot.context.properties.bind.JavaBeanBinder.bind(org.springframework.boot.context.properties.source.ConfigurationPropertyName, org.springframework.boot.context.properties.bind.Bindable<T>, org.springframework.boot.context.properties.bind.Binder.Context, org.springframework.boot.context.properties.bind.BeanPropertyBinder)
                                                            --> boolean hasKnownBindableProperties = hasKnownBindableProperties(name, context); // true
                                                            --> Bean<T> bean = Bean.get(target, hasKnownBindableProperties);
                                                                --> Class<?> type = bindable.getType().resolve(Object.class); // class org.springframework.boot.SpringApplication
                                                                --> type = (instance != null) ? instance.getClass() : type;
                                                                --> Bean<?> bean = new Bean<>(bindable.getType(), type);
                                                                    --> org.springframework.boot.context.properties.bind.JavaBeanBinder.Bean.Bean
                                                                        --> this.resolvableType = resolvableType;
                                                                        --> this.type = type;
                                                                        --> putProperties(type); // class org.springframework.boot.SpringApplication
                                                                                // type 里面包含很多方法，
                                                                            --> for (Method method : type.getDeclaredMethods())
                                                                                --> boolean isCandidate = isCandidate(method)
                                                                                    --> return Modifier.isPublic(modifiers)
                                                                                                && !Modifier.isAbstract(modifiers)
                                                                                                && !Modifier.isStatic(modifiers)
                                                                                                && !Object.class.equals(method.getDeclaringClass())
                                                                                                && !Class.class.equals(method.getDeclaringClass());

                                                                                --> if (isCandidate)
                                                                                    --> addMethod(method); //public java.lang.ClassLoader org.springframework.boot.SpringApplication.getClassLoader()
                                                                                        --> addMethodIfPossible(method, "get", 0, BeanProperty::addGetter);
                                                                                            --> String propertyName = Introspector.decapitalize(method.getName().substring(prefix.length()));
                                                                                            --> consumer.accept(this.properties.computeIfAbsent(propertyName, this::getBeanProperty), method);
                                                                                                --> return new BeanProperty(name, this.resolvableType);
                                                                                                    --> this.name = BeanPropertyName.toDashedForm(name); // name = classLoader, 方法完成之后变成了class-loader
                                                                                                        this.declaringClassType = declaringClassType;

                                                                                        --> addMethodIfPossible(method, "is", 0, BeanProperty::addGetter);
                                                                                        --> addMethodIfPossible(method, "set", 1, BeanProperty::addSetter);

                                                                                    --> addField(field);
                                                                                        --> BeanProperty property = this.properties.get(field.getName());
                                                                                        --> property.addField(field);

                                                                --> return (Bean<T>) bean;

                                                            --> BeanSupplier<T> beanSupplier = bean.getSupplier(target); // JavaBeanBinder$BeanSupplier

                                                            --> boolean bound = bind(propertyBinder, bean, beanSupplier);
                                                                --> String propertyName = property.getName(); // class-loader
                                                                --> ResolvableType type = property.getType(); // java.lang.ClassLoader
                                                                --> Object bound = propertyBinder.bindProperty(propertyName,Bindable.of(type).withSuppliedValue(value).withAnnotations(annotations));

                                                                --> return true;

                                                            --> return (bound ? beanSupplier.get() : null);

                                            --> return handleBindResult(name, target, handler, context, bound);
                                                --> result = handler.onSuccess(name, target, context, result);
                                                    --> return result;
                                                --> BindConverter bindConverter = context.getConverter()
                                                --> result = bindConverter.convert(result, target);
                                                    --> return convert(result, target.getType(), target.getAnnotations());
                                                        --> return (T) this.conversionService.convert(value, TypeDescriptor.forObject(value),new ResolvableTypeDescriptor(type, annotations));
                                                            --> return delegate.convert(source, sourceType, targetType);
                                                                --> GenericConverter converter = getConverter(sourceType, targetType);
                                                                    --> ConverterCacheKey key = new ConverterCacheKey(sourceType, targetType);
                                                                    --> GenericConverter converter = this.converterCache.get(key);
                                                                    --> return converter

                                                                --> Object result = ConversionUtils.invokeConverter(converter, source, sourceType, targetType);
                                                                    --> return converter.convert(source, sourceType, targetType);
                                                                        --> return source;

                                                                --> return handleResult(sourceType, targetType, result);
                                                                    --> return result;

                                                --> handler.onFinish(name, target, context, result);

                                                --> BindConverter bindConverter = context.getConverter()

                                                --> return bindConverter.convert(result, target);
                                                    --> return convert(result, target.getType(), target.getAnnotations());
                                                        --> return (T) this.conversionService.convert(value, TypeDescriptor.forObject(value),new ResolvableTypeDescriptor(type, annotations));
                                                            .
                                                            .
                                                            .
                                                            //解析过程和上面相同

                                        --> return BindResult.of(bound);
                                            --> return new BindResult<>(value);
                                                --> org.springframework.boot.context.properties.bind.BindResult.BindResult
                                                    --> this.value = value;

                        --> ConfigurationPropertySources.attach(environment);
                            --> MutablePropertySources sources = ((ConfigurableEnvironment) environment).getPropertySources();
                            --> PropertySource<?> attached = sources.get("configurationProperties");
                            --> sources.remove("configurationProperties");
                            --> attached = null;

                            --> SpringConfigurationPropertySources springConfigurationPropertySources = new SpringConfigurationPropertySources(sources)
                                --> this.sources = sources;
                            --> ConfigurationPropertySourcesPropertySource configurationPropertySourcesPropertySource = new ConfigurationPropertySourcesPropertySource("configurationProperties",springConfigurationPropertySources);
                                --> this.name = name;
                                    this.source = source;
                            --> sources.addFirst(configurationPropertySourcesPropertySource);
                                --> this.propertySourceList.add(0, propertySource);

                        --> return environment;

                        //遍历调用所有SpringApplicationRunListener的environmentPrepared()的方法，告诉他们：“当前SpringBoot应用使用的Environment准备好了咯！”
                    --> configureIgnoreBeanInfo(environment);
                        --> Boolean ignore = environment.getProperty("spring.beaninfo.ignore",Boolean.class, Boolean.TRUE);
                        --> System.setProperty(CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME,ignore.toString());

                        //如果SpringApplication的showBanner属性被设置为true，则打印banner。
                    --> Banner printedBanner = printBanner(environment);

                        //根据用户是否明确设置了applicationContextClass类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的ApplicationContext并创建完成，然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，当然，最重要的，将之前准备好的Environment设置给创建好的ApplicationContext使用
                        // ApplicationContext创建好之后，SpringApplication会再次借助Spring-FactoriesLoader，查找并加载classpath中所有可用的ApplicationContext-Initializer，然后遍历调用这些ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理。
                    --> context = createApplicationContext();
                        --> Class<?> contextClass = this.applicationContextClass;
                        --> contextClass = Class.forName(DEFAULT_CONTEXT_CLASS); //org.springframework.context.annotation.AnnotationConfigApplicationContext
                        --> return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);
                            --> return instantiateClass(clazz.getDeclaredConstructor());
                                --> return ctor.newInstance(args)

                        //遍历调用所有SpringApplicationRunListener的contextPrepared()方法。
                        //最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext。
                    --> prepareContext(context, environment, listeners, applicationArguments,printedBanner);
                        --> context.setEnvironment(environment);
                            --> org.springframework.context.annotation.AnnotationConfigApplicationContext.setEnvironment
                                --> super.setEnvironment(environment);
                                    --> org.springframework.context.support.AbstractApplicationContext.setEnvironment
                                        --> this.environment = environment;
                                --> this.reader.setEnvironment(environment);
                                    --> org.springframework.context.annotation.AnnotatedBeanDefinitionReader.setEnvironment(Environment environment)
                                        --> this.conditionEvaluator = new ConditionEvaluator(this.registry, environment, null);
                                            --> this.context = new ConditionContextImpl(registry, environment, resourceLoader);
                                                --> org.springframework.context.annotation.ConditionEvaluator.ConditionContextImpl.ConditionContextImpl
                                                    --> this.registry = registry;
                                                    --> this.beanFactory = deduceBeanFactory(registry);
                                                        --> return (((ConfigurableApplicationContext) source).getBeanFactory());
                                                    --> this.environment = (environment != null ? environment : deduceEnvironment(registry));
                                                        --> return new StandardEnvironment();
                                                                //这一步将系统默认的参数添加到了propertySources中
                                                            --> propertySources.addLast(new MapPropertySource("systemProperties", getSystemProperties()));
                                                                propertySources.addLast(new SystemEnvironmentPropertySource("systemEnvironment", getSystemEnvironment()));

                                                    --> this.resourceLoader = (resourceLoader != null ? resourceLoader : deduceResourceLoader(registry));
                                                        --> org.springframework.context.annotation.ConditionEvaluator.ConditionContextImpl.deduceResourceLoader(BeanDefinitionRegistry source)
                                                            --> return (ResourceLoader) source;

                                                    --> this.classLoader = deduceClassLoader(resourceLoader, this.beanFactory);
                                                        --> return beanFactory.getBeanClassLoader();

                                --> this.scanner.setEnvironment(environment);
                                    --> org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.setEnvironment(Environment environment)
                                        --> this.environment = environment;
                                        --> this.conditionEvaluator = null;

                            //看样子像是把容器再检查一遍，该有的都有了之后才去启动容器
                        --> postProcessApplicationContext(context);
                            --> ConversionService conversionService = ApplicationConversionService.getSharedInstance()
                                    //之前这个实例被初始化过了，这里直接返回即可
                                --> return sharedInstance;

                            --> context.getBeanFactory().setConversionService(conversionService);
                                --> org.springframework.beans.factory.support.AbstractBeanFactory.setConversionService(ConversionService conversionService)
                                    --> this.conversionService = conversionService;

                        --> applyInitializers(context);
                            --> org.springframework.boot.SpringApplication.applyInitializers(ConfigurableApplicationContext context)
                                --> Set<ApplicationContextInitializer<?>> set = getInitializers()   // 这里获取的就是上面从spring.factories获取的那几个Initializer
                                --> for (ApplicationContextInitializer initializer : set)
                                    --> Class<?> requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(), ApplicationContextInitializer.class);
                                        --> ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericIfc);
                                        --> return getSingleGeneric(resolvableType);
                                            --> return resolvableType.getGeneric().resolve(); //

                                        //1.DelegatingApplicationContextInitializer implements ApplicationContextInitializer<ConfigurableApplicationContext>, Ordered .initialize(context)
                                    --> org.springframework.boot.context.config.DelegatingApplicationContextInitializer.initialize(context)
                                        --> ConfigurableEnvironment environment = context.getEnvironment();
                                        --> List<Class<?>> initializerClasses = getInitializerClasses(environment);
                                            --> String classNames = env.getProperty("context.initializer.classes"); //null
                                            --> return classes; // emptyList

                                        //2.SharedMetadataReaderFactoryContextInitializer implements ApplicationContextInitializer<ConfigurableApplicationContext>, Ordered .initialize(context)
                                    --> org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer.initialize(context)
                                        --> BeanFactoryPostProcessor postProcessor = new CachingMetadataReaderFactoryPostProcessor()
                                        --> applicationContext.addBeanFactoryPostProcessor(postProcessor);
                                            --> AbstractApplicationContext.beanFactoryPostProcessors.add(postProcessor);

                                        //3.ContextIdApplicationContextInitializer implements ApplicationContextInitializer<ConfigurableApplicationContext>, Ordered .initialize(context)
                                    --> org.springframework.boot.context.ContextIdApplicationContextInitializer.initialize(context)
                                        --> ContextId contextId = getContextId(applicationContext);
                                            --> ApplicationContext parent = applicationContext.getParent();
                                            --> String applicationId = getApplicationId(applicationContext.getEnvironment());
                                                --> String name = environment.getProperty("spring.application.name");
                                                --> return StringUtils.hasText(name) ? name : "application";
                                            --> return new ContextId(applicationId);
                                                --> org.springframework.boot.context.ContextIdApplicationContextInitializer.ContextId(String id)
                                                    --> this.id = id;

                                        --> applicationContext.setId(contextId.getId());
                                        --> ConfigurableListableBeanFactory configurableListableBeanFactory = applicationContext.getBeanFactory()
                                            --> return this.beanFactory;
                                        --> configurableListableBeanFactory.registerSingleton(ContextId.class.getName(),contextId);
                                            --> super.registerSingleton(beanName, singletonObject); // beanName = org.springframework.boot.context.ContextIdApplicationContextInitializer$ContextId
                                                --> org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.registerSingleton(String beanName, Object singletonObject)
                                                    --> addSingleton(beanName, singletonObject);
                                                        --> this.singletonObjects.put(beanName, singletonObject);
                                                            this.singletonFactories.remove(beanName);
                                                            this.earlySingletonObjects.remove(beanName);
                                                            this.registeredSingletons.add(beanName);

                                            --> this.manualSingletonNames.add(beanName);

                                        // 4.ConfigurationWarningsApplicationContextInitializer implements ApplicationContextInitializer<ConfigurableApplicationContext> .initialize
                                    --> org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer.initialize
                                        --> Check[] checks = getChecks()
                                            --> return new Check[] { new ComponentScanPackageCheck() };
                                                    //添加基础包扫描吧
                                                --> Set<String> packages = new HashSet<>();
                                                    packages.add("org.springframework");
                                                    packages.add("org");

                                        --> ConfigurationWarningsPostProcessor configurationWarningsPostProcessor = new ConfigurationWarningsPostProcessor(checks)
                                            --> org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer.ConfigurationWarningsPostProcessor(Check[] checks)
                                                --> this.checks = checks;
                                        --> context.addBeanFactoryPostProcessor(configurationWarningsPostProcessor);
                                            --> AbstractApplicationContext.beanFactoryPostProcessors.add(postProcessor);

                                        // 5. ServerPortInfoApplicationContextInitializer implements ApplicationContextInitializer<ConfigurableApplicationContext>,ApplicationListener<WebServerInitializedEvent>
                                    --> org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer.initialize
                                        --> applicationContext.addApplicationListener(this);
                                            --> AbstractApplicationContext.applicationListeners.add(listener);

                                        // 6. ConditionEvaluationReportLoggingListener implements ApplicationContextInitializer<ConfigurableApplicationContext>
                                    --> org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener.initialize
                                        --> this.applicationContext = applicationContext;
                                        --> applicationContext.addApplicationListener(new ConditionEvaluationReportListener());
                                        --> this.report = ConditionEvaluationReport.get(this.applicationContext.getBeanFactory());

                        --> listeners.contextPrepared(context);
                            --> for (SpringApplicationRunListener listener : this.listeners) //现在里面就一个 eventPublishingRunListener
                                --> org.springframework.boot.context.event.EventPublishingRunListener.contextPrepared(context)
                                    --> ApplicationContextInitializedEvent applicationContextInitializedEvent = new ApplicationContextInitializedEvent(this.application, this.args, context)
                                        --> super(application, args);
                                            --> org.springframework.boot.context.event.SpringApplicationEvent
                                                --> super(application);
                                                    --> org.springframework.context.ApplicationEvent.ApplicationEvent
                                                        --> super(source);
                                                            --> java.util.EventObject.EventObject
                                                                --> this.source = source;
                                                --> this.args = args;
                                        --> this.context = context;
                                    --> this.initialMulticaster.multicastEvent(applicationContextInitializedEvent);
                                        --> org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(org.springframework.context.ApplicationEvent)
                                            --> ResolvableType resolvableType = resolveDefaultEventType(event)
                                                --> return ResolvableType.forInstance(event);
                                                    --> return ResolvableType.forClass(instance.getClass());

                                            --> multicastEvent(event, resolvableType);
                                                --> ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));
                                                --> ApplicationListener listeners = getApplicationListeners(event, type)
                                                --> for (final ApplicationListener<?> listener : listeners)
                                                    .
                                                    .
                                                    .//执行和之前的步骤相同

                        --> ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
                            --> org.springframework.context.support.GenericApplicationContext.getBeanFactory
                                --> return this.beanFactory; // DefaultListableBeanFactory

                        --> beanFactory.registerSingleton("springApplicationArguments", applicationArguments);
                            --> org.springframework.beans.factory.support.DefaultListableBeanFactory.registerSingleton
                                --> super.registerSingleton(beanName, singletonObject);
                                    --> addSingleton(beanName, singletonObject);
                                        --> this.singletonObjects.put(beanName, singletonObject);
                                            this.singletonFactories.remove(beanName);
                                            this.earlySingletonObjects.remove(beanName);
                                            this.registeredSingletons.add(beanName);
                                --> this.manualSingletonNames.add(beanName);

                        --> beanFactory.registerSingleton("springBootBanner", printedBanner);

                        --> if (beanFactory instanceof DefaultListableBeanFactory)
                            --> ((DefaultListableBeanFactory) beanFactory).setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); // false

                            // Load the sources
                        --> Set<Object> sources = getAllSources();
                            --> org.springframework.boot.SpringApplication.getAllSources
                                --> Set<Object> allSources = new LinkedHashSet<>();
                                    // 这个类是导入的入口
                                --> allSources.addAll(this.primarySources); // 现在里面有一个class org.springframework.cloud.bootstrap.BootstrapImportSelectorConfiguration
                                --> return Collections.unmodifiableSet(allSources);

                        --> load(context, sources.toArray(new Object[0]));
                            --> org.springframework.boot.SpringApplication.load
                                --> BeanDefinitionRegistry beanDefinitionRegistry= getBeanDefinitionRegistry(context)
                                    --> return (BeanDefinitionRegistry) context;
                                --> BeanDefinitionLoader loader = createBeanDefinitionLoader(beanDefinitionRegistry, sources);
                                    --> return new BeanDefinitionLoader(registry, sources);
                                        --> org.springframework.boot.BeanDefinitionLoader.BeanDefinitionLoader

                                            --> this.sources = sources; //class org.springframework.cloud.bootstrap.BootstrapImportSelectorConfiguration

                                            --> this.annotatedReader = new AnnotatedBeanDefinitionReader(registry);
                                                --> org.springframework.context.annotation.AnnotatedBeanDefinitionReader.AnnotatedBeanDefinitionReader(org.springframework.beans.factory.support.BeanDefinitionRegistry)
                                                    --> Environment environment = getOrCreateEnvironment(registry)
                                                            //这一步在之前初始化过了，直接获取即可
                                                        --> return ((EnvironmentCapable) registry).getEnvironment();
                                                    --> this(registry, environment);
                                                        --> this.registry = registry; // org.springframework.context.annotation.AnnotationConfigApplicationContext
                                                        --> this.conditionEvaluator = new ConditionEvaluator(registry, environment, null);
                                                            --> this.context = new ConditionContextImpl(registry, environment, resourceLoader);
                                                                --> this.registry = registry;
                                                                --> this.beanFactory = deduceBeanFactory(registry);
                                                                --> this.environment = (environment != null ? environment : deduceEnvironment(registry));
                                                                --> this.resourceLoader = (resourceLoader != null ? resourceLoader : deduceResourceLoader(registry));
                                                                --> this.classLoader = deduceClassLoader(resourceLoader, this.beanFactory);
                                                                .
                                                                .
                                                                .//和上面的代码步骤相同

                                                        --> AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
                                                            --> org.springframework.context.annotation.AnnotationConfigUtils.registerAnnotationConfigProcessors(org.springframework.beans.factory.support.BeanDefinitionRegistry)
                                                                --> registerAnnotationConfigProcessors(registry, null);
                                                                    --> DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);
                                                                        --> return ((GenericApplicationContext) registry).getDefaultListableBeanFactory();
                                                                            --> org.springframework.context.support.GenericApplicationContext.getDefaultListableBeanFactory
                                                                                --> return this.beanFactory;  //org.springframework.beans.factory.support.DefaultListableBeanFactory@21ba0741: defining beans [org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.event.internalEventListenerProcessor,org.springframework.context.event.internalEventListenerFactory]; root of factory hierarchy

                                                                    --> Set<BeanDefinitionHolder> beanDefs = new LinkedHashSet<>(8);
                                                                    --> if (!registry.containsBeanDefinition("org.springframework.context.annotation.internalConfigurationAnnotationProcessor"))
                                                                        --> RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);
                                                                            --> org.springframework.beans.factory.support.RootBeanDefinition.RootBeanDefinition(java.lang.Class<?>)
                                                                                --> super();
                                                                                    --> org.springframework.beans.factory.support.AbstractBeanDefinition.AbstractBeanDefinition()
                                                                                        --> this.constructorArgumentValues = null;
                                                                                        --> this.propertyValues = null;
                                                                                --> setBeanClass(beanClass);
                                                                                    --> this.beanClass = beanClass;

                                                                        --> def.setSource(source);
                                                                        --> BeanDefinitionHolder beanDefinitionHolder = registerPostProcessor(registry, def, "org.springframework.context.annotation.internalConfigurationAnnotationProcessor")
                                                                                //Set the role hint for this {@code BeanDefinition}.
                                                                            --> definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);

                                                                            --> registry.registerBeanDefinition(beanName, definition);
                                                                                --> org.springframework.context.support.GenericApplicationContext.registerBeanDefinition
                                                                                    --> this.beanFactory.registerBeanDefinition(beanName, beanDefinition);
                                                                                        --> org.springframework.beans.factory.support.DefaultListableBeanFactory.registerBeanDefinition
                                                                                            --> BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
                                                                                            --> this.beanDefinitionMap.put(beanName, beanDefinition);
                                                                                            --> this.beanDefinitionNames.add(beanName);
                                                                                            --> this.manualSingletonNames.remove(beanName);
                                                                                            --> this.frozenBeanDefinitionNames = null;

                                                                            --> return new BeanDefinitionHolder(definition, beanName); // beanName = org.springframework.context.annotation.internalConfigurationAnnotationProcessor
                                                                                --> org.springframework.beans.factory.config.BeanDefinitionHolder.BeanDefinitionHolder(org.springframework.beans.factory.config.BeanDefinition, java.lang.String)
                                                                                    --> this.beanDefinition = beanDefinition;
                                                                                    --> this.beanName = beanName;
                                                                                    --> this.aliases = null;

                                                                        --> beanDefs.add(beanDefinitionHolder);

                                                                        // 根据registry中是否包含bean，如果不包含就进行初始化，规则和上面一样
                                                                    --> if (!registry.containsBeanDefinition("org.springframework.context.annotation.internalAutowiredAnnotationProcessor"))
                                                                    --> if (jsr250Present && !registry.containsBeanDefinition("org.springframework.context.annotation.internalCommonAnnotationProcessor"))
                                                                    --> if (jpaPresent && !registry.containsBeanDefinition("org.springframework.context.annotation.internalCommonAnnotationProcessor"))
                                                                        --> RootBeanDefinition def = new RootBeanDefinition();
                                                                        --> def.setBeanClass(ClassUtils.forName("org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor",AnnotationConfigUtils.class.getClassLoader()));
                                                                    --> if (!registry.containsBeanDefinition("org.springframework.context.event.internalEventListenerProcessor"))
                                                                    --> if (!registry.containsBeanDefinition("org.springframework.context.event.internalEventListenerFactory"))

                                                                    --> return beanDefs;

                                            --> this.xmlReader = new XmlBeanDefinitionReader(registry);
                                                --> org.springframework.beans.factory.xml.XmlBeanDefinitionReader.XmlBeanDefinitionReader
                                                    --> super()
                                                        --> org.springframework.beans.factory.support.AbstractBeanDefinitionReader.AbstractBeanDefinitionReader
                                                            --> this.registry = registry;
                                                            --> this.resourceLoader = (ResourceLoader) this.registry;
                                                            --> this.environment = ((EnvironmentCapable) this.registry).getEnvironment();

                                                //加载classpath下面的bean
                                            --> this.scanner = new ClassPathBeanDefinitionScanner(registry);
                                                --> org.springframework.context.annotation.ClassPathBeanDefinitionScanner.ClassPathBeanDefinitionScanner(org.springframework.beans.factory.support.BeanDefinitionRegistry)
                                                    --> this(registry, useDefaultFilters, getOrCreateEnvironment(registry));
                                                        --> this(registry, useDefaultFilters, environment,(registry instanceof ResourceLoader ? (ResourceLoader) registry : null));
                                                            --> this.registry = registry;

                                                                //注册一些默认的filters
                                                            --> registerDefaultFilters();
                                                                    //Register the default filter for {@link Component @Component}.
                                                                --> this.includeFilters.add(new AnnotationTypeFilter(Component.class));
                                                                    --> org.springframework.core.type.filter.AnnotationTypeFilter.AnnotationTypeFilter(java.lang.Class<? extends java.lang.annotation.Annotation>)
                                                                        --> this(annotationType, true, false);
                                                                            --> super(annotationType.isAnnotationPresent(Inherited.class), considerInterfaces);
                                                                                --> org.springframework.core.type.filter.AbstractTypeHierarchyTraversingFilter.AbstractTypeHierarchyTraversingFilter
                                                                                    --> this.considerInherited = considerInherited; // false
                                                                                    --> this.considerInterfaces = considerInterfaces; // false
                                                                            --> this.annotationType = annotationType; // interface org.springframework.stereotype.Component
                                                                            --> this.considerMetaAnnotations = considerMetaAnnotations; // true

                                                                --> ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();
                                                                --> this.includeFilters.add(new AnnotationTypeFilter(((Class<? extends Annotation>) ClassUtils.forName("javax.annotation.ManagedBean", cl)), false));
                                                                --> this.includeFilters.add(new AnnotationTypeFilter(((Class<? extends Annotation>) ClassUtils.forName("javax.inject.Named", cl)), false));

                                                            --> setEnvironment(environment);
                                                                --> org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.setEnvironment(Environment environment)
                                                                    --> this.environment = environment;
                                                                    --> this.conditionEvaluator = null;

                                                            --> setResourceLoader(resourceLoader);
                                                                --> org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.setResourceLoader(ResourceLoader resourceLoader)
                                                                    --> this.resourcePatternResolver = ResourcePatternUtils.getResourcePatternResolver(resourceLoader);
                                                                        --> return (ResourcePatternResolver) resourceLoader;
                                                                    --> this.metadataReaderFactory = new CachingMetadataReaderFactory(resourceLoader);
                                                                        --> org.springframework.core.type.classreading.CachingMetadataReaderFactory.CachingMetadataReaderFactory(org.springframework.core.io.ResourceLoader)
                                                                            --> super(resourceLoader);
                                                                                --> org.springframework.core.type.classreading.SimpleMetadataReaderFactory.SimpleMetadataReaderFactory(org.springframework.core.io.ResourceLoader)
                                                                                    --> this.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader());
                                                                            --> this.metadataReaderCache = ((DefaultResourceLoader) resourceLoader).getResourceCache(MetadataReader.class);

                                                                    --> this.componentsIndex = CandidateComponentsIndexLoader.loadIndex(this.resourcePatternResolver.getClassLoader());
                                                                        --> org.springframework.context.index.CandidateComponentsIndex
                                                                            --> ClassLoader classLoaderToUse = classLoader;
                                                                            --> return cache.computeIfAbsent(classLoaderToUse, CandidateComponentsIndexLoader::doLoadIndex);
                                                                                --> Enumeration<URL> urls = classLoader.getResources("META-INF/spring.components");
                                                                                --> URL url = urls.nextElement();
                                                                                --> Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url));
                                                                                --> result.add(properties);

                                            --> this.scanner.addExcludeFilter(new ClassExcludeFilter(sources));
                                                --> org.springframework.boot.BeanDefinitionLoader.ClassExcludeFilter.ClassExcludeFilter
                                                    --> super(false, false);
                                                        --> this.considerInherited = considerInherited; // false
                                                        --> this.considerInterfaces = considerInterfaces; // false

                                                        //要把之前的类排除出去
                                                    --> this.classNames.add(((Class<?>) source).getName()); // org.springframework.cloud.bootstrap.BootstrapImportSelectorConfiguration

                                --> loader.setEnvironment(this.environment);
                                    --> org.springframework.boot.BeanDefinitionLoader.setEnvironment
                                        --> this.annotatedReader.setEnvironment(environment);
                                        --> this.xmlReader.setEnvironment(environment);
                                        --> this.scanner.setEnvironment(environment);

                                --> loader.load();
                                    --> if (isComponent(source))
                                        --> if (AnnotationUtils.findAnnotation(type, Component.class) != null)
                                        --> this.annotatedReader.register(source); // source = class org.springframework.cloud.bootstrap.BootstrapImportSelectorConfiguration
                                            --> registerBean(annotatedClass);
                                                    //Register a bean from the given bean class, deriving its metadata from class-declared annotations.
                                                --> doRegisterBean(annotatedClass, null, null, null);
                                                    --> AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);
                                                        --> org.springframework.beans.factory.annotation.AnnotatedGenericBeanDefinition.AnnotatedGenericBeanDefinition(java.lang.Class<?>)
                                                            --> setBeanClass(beanClass);
                                                                --> org.springframework.beans.factory.support.AbstractBeanDefinition.setBeanClass
                                                                    --> this.beanClass = beanClass;

                                                            --> this.metadata = new StandardAnnotationMetadata(beanClass, true);
                                                                --> org.springframework.core.type.StandardAnnotationMetadata.StandardAnnotationMetadata(java.lang.Class<?>, boolean)
                                                                    --> super(introspectedClass);
                                                                        --> org.springframework.core.type.StandardClassMetadata.StandardClassMetadata
                                                                            --> this.introspectedClass = introspectedClass;

                                                                        //读取到了BootstrapImportSelectorConfiguration这个类上面的两个注解
                                                                    --> this.annotations = introspectedClass.getAnnotations(); //[@org.springframework.context.annotation.Configuration(value=),@org.springframework.context.annotation.Import(value=[class org.springframework.cloud.bootstrap.BootstrapImportSelector])]
                                                                        --> java.lang.Class.getAnnotations
                                                                            --> return AnnotationParser.toArray(annotationData().annotations);

                                                                    --> this.nestedAnnotationsAsMap = true;

                                                    --> abd.setInstanceSupplier(instanceSupplier); // null

                                                    --> ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);
                                                        --> org.springframework.context.annotation.AnnotationScopeMetadataResolver.resolveScopeMetadata(BeanDefinition definition)
                                                            --> ScopeMetadata metadata = new ScopeMetadata();
                                                            --> AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition;
                                                            --> AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(annDef.getMetadata(), this.scopeAnnotationType);
                                                                --> org.springframework.context.annotation.AnnotationConfigUtils.attributesFor(org.springframework.core.type.AnnotatedTypeMetadata, java.lang.Class<?>)
                                                                    --> return attributesFor(metadata, annotationClass.getName());
                                                                        --> Map<String, Object> metadataMap = metadata.getAnnotationAttributes(annotationClassName, false)
                                                                            --> return AnnotatedElementUtils.getMergedAnnotationAttributes(getIntrospectedClass(), annotationName, classValuesAsString, this.nestedAnnotationsAsMap)
                                                                                --> Processor<T> processor = new MergedAnnotationAttributesProcessor(classValuesAsString, nestedAnnotationsAsMap)
                                                                                    --> org.springframework.core.annotation.AnnotatedElementUtils.MergedAnnotationAttributesProcessor#MergedAnnotationAttributesProcessor(boolean, boolean)
                                                                                        --> this.classValuesAsString = classValuesAsString; // false
                                                                                        --> this.nestedAnnotationsAsMap = nestedAnnotationsAsMap; // true
                                                                                        --> this.aggregates = aggregates; // false
                                                                                        --> this.aggregatedResults = Collections.emptyList();

                                                                                --> AnnotationAttributes attributes = searchWithGetSemantics(element, null, annotationName,processor);
                                                                                    --> org.springframework.core.annotation.AnnotatedElementUtils.searchWithGetSemantics(java.lang.reflect.AnnotatedElement, java.lang.Class<? extends java.lang.annotation.Annotation>, java.lang.String, org.springframework.core.annotation.AnnotatedElementUtils.Processor<T>)
                                                                                        --> return searchWithGetSemantics(element,Collections.emptySet(),annotationName, null, processor);
                                                                                            --> return searchWithGetSemantics(element, annotationTypes, annotationName, containerType, processor,new HashSet<>(), 0);
                                                                                                --> List<Annotation> declaredAnnotations = Arrays.asList(AnnotationUtils.getDeclaredAnnotations(element)); // [@org.springframework.context.annotation.Configuration(value=),@org.springframework.context.annotation.Import(value=[class org.springframework.cloud.bootstrap.BootstrapImportSelector])]
                                                                                                --> T result = searchWithGetSemanticsInAnnotations(element, declaredAnnotations, annotationTypes, annotationName, containerType, processor, visited, metaDepth);
                                                                                                    --> for (Annotation annotation : annotations)
                                                                                                        --> Class<? extends Annotation> currentAnnotationType = annotation.annotationType();
                                                                                                        --> T result = searchWithGetSemantics(currentAnnotationType, annotationTypes, annotationName, containerType, processor, visited, metaDepth + 1);
                                                                                                            --> return null;
                                                                                                --> Class<?> superclass = ((Class<?>) element).getSuperclass();
                                                                                                --> return null;

                                                                                --> AnnotationUtils.postProcessAnnotationAttributes(element, attributes, classValuesAsString, nestedAnnotationsAsMap);
                                                                                    --> return null

                                                                                --> return attributes; // null

                                                                        --> return AnnotationAttributes.fromMap(metadataMap);
                                                                            --> return null

                                                            --> return metadata; // 没有进行操作，只有初始化的两个属性scopeName:singleton，scopedProxyMode:no

                                                    --> abd.setScope(scopeMetadata.getScopeName()); // singleton

                                                    --> String beanName = this.beanNameGenerator.generateBeanName(abd, this.registry);
                                                        --> org.springframework.context.annotation.AnnotationBeanNameGenerator.generateBeanName
                                                            --> String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);
                                                                --> return null
                                                            --> return buildDefaultBeanName(definition, registry);
                                                                --> return buildDefaultBeanName(definition);
                                                                    --> String beanClassName = definition.getBeanClassName(); // org.springframework.cloud.bootstrap.BootstrapImportSelectorConfiguration
                                                                    --> String shortClassName = ClassUtils.getShortName(beanClassName); // BootstrapImportSelectorConfiguration
                                                                        //将首字母变成小写
                                                                    --> return Introspector.decapitalize(shortClassName); // bootstrapImportSelectorConfiguration

                                                    --> AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
                                                        --> org.springframework.context.annotation.AnnotationConfigUtils.processCommonDefinitionAnnotations(org.springframework.beans.factory.annotation.AnnotatedBeanDefinition)
                                                            --> processCommonDefinitionAnnotations(abd, abd.getMetadata());
                                                                --> AnnotationAttributes lazy = attributesFor(metadata, Lazy.class);
                                                                --> if (metadata.isAnnotated(Primary.class.getName()))
                                                                --> AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);
                                                                --> AnnotationAttributes role = attributesFor(metadata, Role.class);
                                                                --> AnnotationAttributes description = attributesFor(metadata, Description.class);

                                                    --> BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
                                                        --> org.springframework.beans.factory.config.BeanDefinitionHolder.BeanDefinitionHolder(org.springframework.beans.factory.config.BeanDefinition, java.lang.String)
                                                            --> this.beanDefinition = beanDefinition;
                                                            --> this.beanName = beanName; // bootstrapImportSelectorConfiguration
                                                            --> this.aliases = aliases; // null

                                                    --> definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
                                                        --> org.springframework.context.annotation.AnnotationConfigUtils.applyScopedProxyMode(ScopeMetadata metadata, BeanDefinitionHolder definition, BeanDefinitionRegistry registry)
                                                            --> ScopedProxyMode scopedProxyMode = metadata.getScopedProxyMode(); //no
                                                            --> return definition;

                                                    --> BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
                                                        --> org.springframework.beans.factory.support.BeanDefinitionReaderUtils.registerBeanDefinition
                                                            --> String beanName = definitionHolder.getBeanName(); // bootstrapImportSelectorConfiguration
                                                            --> registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
                                                                --> org.springframework.context.support.GenericApplicationContext.registerBeanDefinition
                                                                    --> this.beanFactory.registerBeanDefinition(beanName, beanDefinition);
                                                                        --> BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
                                                                        --> this.beanDefinitionMap.put(beanName, beanDefinition);
                                                                        --> this.beanDefinitionNames.add(beanName);
                                                                        --> this.manualSingletonNames.remove(beanName);
                                                                        --> this.frozenBeanDefinitionNames = null;

                            //遍历调用所有SpringApplicationRunListener的contextLoaded()方法。
                        --> listeners.contextLoaded(context);
                            --> for (SpringApplicationRunListener listener : this.listeners) // EventPublishingRunListener
                                --> listener.contextLoaded(context);
                                    --> org.springframework.boot.context.event.EventPublishingRunListener.contextLoaded
                                        --> for (ApplicationListener<?> listener : this.application.getListeners())  // 13个listener
                                                //实现了ApplicationContextAware接口的就在这一步注入context
                                            --> if (listener instanceof ApplicationContextAware)
                                                --> ((ApplicationContextAware) listener).setApplicationContext(context);
                                            --> context.addApplicationListener(listener);
                                            --> this.initialMulticaster.multicastEvent(new ApplicationPreparedEvent(this.application, this.args, context));


                        //调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。
                    --> refreshContext(context);
                        --> refresh(context);
                            --> ((AbstractApplicationContext) applicationContext).refresh();
                                --> org.springframework.context.support.AbstractApplicationContext.refresh
                                        // Prepare this context for refreshing.
                                    --> prepareRefresh();
                                        --> org.springframework.context.support.AbstractApplicationContext.prepareRefresh
                                                // Initialize any placeholder property sources in the context environment
                                            --> initPropertySources();
                                                --> // For subclasses: do nothing by default.

                                                // Validate that all properties marked as required are resolvable
                                                // see ConfigurablePropertyResolver#setRequiredProperties
                                                // 验证一下需要依赖的组件是否都有，没有注入
                                            --> getEnvironment().validateRequiredProperties();

                                                // Allow for the collection of early ApplicationEvents,
                                                // to be published once the multicaster is available...
                                            --> this.earlyApplicationEvents = new LinkedHashSet<>();

                                        // Tell the subclass to refresh the internal bean factory.
                                    --> ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
                                        --> org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory
                                            --> refreshBeanFactory();
                                                --> org.springframework.context.support.GenericApplicationContext.refreshBeanFactory
                                                    --> this.beanFactory.setSerializationId(getId());
                                                        --> org.springframework.beans.factory.support.DefaultListableBeanFactory.setSerializationId
                                                            --> serializableFactories.put(serializationId, new WeakReference<>(this)); //serializationId = application(因为没有指定spring.application.name)
                                                                --> java.lang.ref.Reference.Reference(T, java.lang.ref.ReferenceQueue<? super T>)
                                                                    --> this.referent = referent;
                                                                        this.queue = (queue == null) ? ReferenceQueue.NULL : queue;

                                            --> return getBeanFactory();
                                                --> org.springframework.context.support.GenericApplicationContext.getBeanFactory
                                                    --> return this.beanFactory;

                                        // Prepare the bean factory for use in this context.
                                    --> prepareBeanFactory(beanFactory);
                                        --> beanFactory.setBeanClassLoader(getClassLoader());
                                        --> beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
                                            --> org.springframework.context.expression.StandardBeanExpressionResolver.StandardBeanExpressionResolver(java.lang.ClassLoader)
                                                --> SpelParserConfiguration spelParserConfiguration = new SpelParserConfiguration(null, beanClassLoader)

                                                --> this.expressionParser = new SpelExpressionParser(spelParserConfiguration);
                                                    --> org.springframework.expression.spel.SpelParserConfiguration.SpelParserConfiguration(org.springframework.expression.spel.SpelCompilerMode, java.lang.ClassLoader)
                                                        --> this(compilerMode, compilerClassLoader, false, false, Integer.MAX_VALUE);
                                                            --> this.compilerMode = (compilerMode != null ? compilerMode : defaultCompilerMode);
                                                                this.compilerClassLoader = compilerClassLoader;
                                                                this.autoGrowNullReferences = autoGrowNullReferences;
                                                                this.autoGrowCollections = autoGrowCollections;
                                                                this.maximumAutoGrowSize = maximumAutoGrowSize;

                                                    --> this.configuration = configuration;

                                        --> ResourceEditorRegistrar resourceEditorRegistrar = new ResourceEditorRegistrar(this, getEnvironment())
                                            --> org.springframework.beans.support.ResourceEditorRegistrar.ResourceEditorRegistrar
                                                --> this.resourceLoader = resourceLoader;
                                                    this.propertyResolver = propertyResolver;

                                        --> beanFactory.addPropertyEditorRegistrar(resourceEditorRegistrar);
                                            --> this.propertyEditorRegistrars.add(registrar);
                                                --> this.propertyEditorRegistrars.add(registrar);

                                            // Configure the bean factory with context callbacks.
                                        --> BeanPostProcessor beanPostProcessor = new ApplicationContextAwareProcessor(this)
                                            --> org.springframework.context.support.ApplicationContextAwareProcessor.ApplicationContextAwareProcessor
                                                --> this.applicationContext = applicationContext;
                                                --> this.embeddedValueResolver = new EmbeddedValueResolver(applicationContext.getBeanFactory());
                                                    --> org.springframework.beans.factory.config.EmbeddedValueResolver.EmbeddedValueResolver
                                                        --> this.exprContext = new BeanExpressionContext(beanFactory, null);
                                                            --> org.springframework.beans.factory.config.BeanExpressionContext.BeanExpressionContext
                                                                --> this.beanFactory = beanFactory;
                                                                    this.scope = scope;

                                                        --> this.exprResolver = beanFactory.getBeanExpressionResolver();
                                                            --> org.springframework.beans.factory.support.AbstractBeanFactory.getBeanExpressionResolver
                                                                --> return this.beanExpressionResolver;

                                        --> beanFactory.addBeanPostProcessor(beanPostProcessor);
                                                // Remove from old position, if any
                                            --> this.beanPostProcessors.remove(beanPostProcessor);
                                                // Add to end of list
                                            --> this.beanPostProcessors.add(beanPostProcessor);

                                        --> beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
                                        --> beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
                                        --> beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
                                        --> beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
                                        --> beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
                                        --> beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

                                            // BeanFactory interface not registered as resolvable type in a plain factory.
                                            // MessageSource registered (and found for autowiring) as a bean.
                                        --> beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
                                                /** Map from dependency type to corresponding autowired value. */
                                            --> private final Map<Class<?>, Object> resolvableDependencies = new ConcurrentHashMap<>(16);
                                            --> this.resolvableDependencies.put(dependencyType, autowiredValue);

                                        --> beanFactory.registerResolvableDependency(ResourceLoader.class, this);
                                        --> beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
                                        --> beanFactory.registerResolvableDependency(ApplicationContext.class, this);

                                            // Register early post-processor for detecting inner beans as ApplicationListeners.
                                        --> beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));
                                            --> org.springframework.context.support.ApplicationListenerDetector.ApplicationListenerDetector
                                                --> this.applicationContext = applicationContext;
                                                // Remove from old position, if any
                                            --> this.beanPostProcessors.remove(beanPostProcessor);
                                            --> this.hasDestructionAwareBeanPostProcessors = true;
                                                // Add to end of list
                                            --> this.beanPostProcessors.add(beanPostProcessor);

                                        --> if(!beanFactory.containsLocalBean("environment"))
                                            --> beanFactory.registerSingleton("environment", getEnvironment());
                                                --> org.springframework.beans.factory.support.DefaultListableBeanFactory.registerSingleton
                                                    --> super.registerSingleton(beanName, singletonObject);
                                                        --> addSingleton(beanName, singletonObject);
                                                            --> this.singletonObjects.put(beanName, singletonObject);
                                                                this.singletonFactories.remove(beanName);
                                                                this.earlySingletonObjects.remove(beanName);
                                                                this.registeredSingletons.add(beanName);

                                                    --> this.manualSingletonNames.add(beanName);

                                        --> if (!beanFactory.containsLocalBean("systemProperties"))
                                            --> beanFactory.registerSingleton(systemProperties, getEnvironment().getSystemProperties());
                                                --> super.registerSingleton(beanName, singletonObject);
                                                    --> addSingleton(beanName, singletonObject);
                                                        --> this.singletonObjects.put(beanName, singletonObject);
                                                            this.singletonFactories.remove(beanName);
                                                            this.earlySingletonObjects.remove(beanName);
                                                            this.registeredSingletons.add(beanName);

                                                --> this.manualSingletonNames.add(beanName);

                                        --> if (!beanFactory.containsLocalBean("systemEnvironment"))
                                            --> beanFactory.registerSingleton("systemEnvironment", getEnvironment().getSystemEnvironment());
                                                --> 和上面注册步骤一样

                                        // Allows post-processing of the bean factory in context subclasses.
                                    --> postProcessBeanFactory(beanFactory);
                                        --> org.springframework.context.support.AbstractApplicationContext.postProcessBeanFactory
                                                //空方法
                                                /**
                                                 * Modify the application context's internal bean factory after its standard
                                                 * initialization. All bean definitions will have been loaded, but no beans
                                                 * will have been instantiated yet. This allows for registering special
                                                 * BeanPostProcessors etc in certain ApplicationContext implementations.
                                                 * @param beanFactory the bean factory used by the application context
                                                 */

                                        // Invoke factory processors registered as beans in the context.
                                    --> invokeBeanFactoryPostProcessors(beanFactory);
                                        --> org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors
                                            --> PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
                                                --> org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List<org.springframework.beans.factory.config.BeanFactoryPostProcessor>)
                                                    --> Set<String> processedBeans = new HashSet<>();
                                                    --> BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
                                                    --> List<BeanFactoryPostProcessor> regularPostProcessors = new ArrayList<>();
                                                    --> List<BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList<>();
                                                    --> for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) //[SharedMetadataReaderFactoryContextInitializer$CachingMetadataReaderFactoryPostProcessor,ConfigurationWarningsApplicationContextInitializer$ConfigurationWarningsPostProcessor,ConfigFileApplicationListener$PropertySourceOrderingPostProcessor]
                                                        --> if (postProcessor instanceof BeanDefinitionRegistryPostProcessor)
                                                            --> BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor;
                                                            --> registryProcessor.postProcessBeanDefinitionRegistry(registry);
                                                                --> register(registry);
                                                                    --> BeanDefinition definition = BeanDefinitionBuilder.genericBeanDefinition(SharedMetadataReaderFactoryBean.class,SharedMetadataReaderFactoryBean::new).getBeanDefinition();
                                                                        --> org.springframework.beans.factory.support.BeanDefinitionBuilder#genericBeanDefinition(java.lang.Class<T>, java.util.function.Supplier<T>)
                                                                            --> BeanDefinitionBuilder builder = new BeanDefinitionBuilder(new GenericBeanDefinition());
                                                                            --> builder.beanDefinition.setBeanClass(beanClass); //class org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer$SharedMetadataReaderFactoryBean
                                                                            --> builder.beanDefinition.setInstanceSupplier(instanceSupplier);
                                                                            --> return builder;

                                                                        --> return this.beanDefinition;

                                                                    --> registry.registerBeanDefinition("org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory", definition);
                                                                        --> org.springframework.beans.factory.support.DefaultListableBeanFactory.registerBeanDefinition
                                                                            --> BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName); // org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory
                                                                            --> this.beanDefinitionMap.put(beanName, beanDefinition);
                                                                                this.beanDefinitionNames.add(beanName);
                                                                                this.manualSingletonNames.remove(beanName);
                                                                                this.frozenBeanDefinitionNames = null;

                                                                --> configureConfigurationClassPostProcessor(registry);
                                                                    --> BeanDefinition definition = registry.getBeanDefinition("org.springframework.context.annotation.internalConfigurationAnnotationProcessor");
                                                                    --> definition.getPropertyValues().add("metadataReaderFactory", new RuntimeBeanReference("org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory"));

                                                            --> registryProcessors.add(registryProcessor);

                                                        --> else
                                                            --> regularPostProcessors.add(postProcessor);

                                                    --> List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();

                                                        // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
                                                    --> String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
                                                        --> return doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit);

                                                    --> for (String ppName : postProcessorNames)
                                                        --> if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class))
                                                            --> currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                                                                --> org.springframework.beans.factory.support.AbstractBeanFactory.getBean(java.lang.String, java.lang.Class<T>)
                                                                    --> return doGetBean(name, requiredType, null, false);
                                                                        --> final String beanName = transformedBeanName(name);
                                                                        --> Object sharedInstance = getSingleton(beanName);
                                                                        --> BeanFactory parentBeanFactory = getParentBeanFactory();
                                                                        --> markBeanAsCreated(beanName);
                                                                            --> this.alreadyCreated.add(beanName);
                                                                        --> final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
                                                                            --> return getMergedBeanDefinition(beanName, getBeanDefinition(beanName));
                                                                                --> RootBeanDefinition mbd = this.mergedBeanDefinitions.get(beanName);
                                                                                --> mbd = ((RootBeanDefinition) bd).cloneBeanDefinition();
                                                                                --> mbd.setScope(RootBeanDefinition.SCOPE_SINGLETON);
                                                                                --> this.mergedBeanDefinitions.put(beanName, mbd);
                                                                                --> return mbd;
                                                                        --> String[] dependsOn = mbd.getDependsOn();
                                                                        --> return createBean(beanName, mbd, args);
                                                                            --> org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(java.lang.String, org.springframework.beans.factory.ObjectFactory<?>)
                                                                                --> Object singletonObject = this.singletonObjects.get(beanName);
                                                                                --> if (singletonObject == null)
                                                                                    --> singletonObject = singletonFactory.getObject();
                                                                                --> addSingleton(beanName, singletonObject);
                                                                                    --> this.singletonObjects.put(beanName, singletonObject);
                                                                                        this.singletonFactories.remove(beanName);
                                                                                        this.earlySingletonObjects.remove(beanName);
                                                                                        this.registeredSingletons.add(beanName);
                                                                                --> return singletonObject;

                                                                        --> bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                                                                            --> return super.getObjectForBeanInstance(beanInstance, name, beanName, mbd);
                                                                                --> org.springframework.beans.factory.support.AbstractBeanFactory.getObjectForBeanInstance
                                                                                    --> return beanInstance;


                                                                        --> return (T) bean;

                                                            --> processedBeans.add(ppName);

                                                    --> invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);

                                                        --> for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) //[ConfigurationClassPostProcessor]
                                                            --> postProcessor.postProcessBeanDefinitionRegistry(registry);
                                                                --> org.springframework.context.annotation.ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry
                                                                    --> int registryId = System.identityHashCode(registry);
                                                                    --> this.registriesPostProcessed.add(registryId);
                                                                    --> processConfigBeanDefinitions(registry);
                                                                        --> List<BeanDefinitionHolder> configCandidates = new ArrayList<>();
                                                                        --> String[] candidateNames = registry.getBeanDefinitionNames();
                                                                            --> BeanDefinition beanDef = registry.getBeanDefinition(beanName); // org.springframework.context.annotation.internalConfigurationAnnotationProcessor
                                                                            --> boolean isConfig = ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory);
                                                                                --> String className = beanDef.getBeanClassName(); // org.springframework.context.annotation.ConfigurationClassPostProcessor
                                                                                --> if (beanDef instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) beanDef).hasBeanClass())
                                                                                    --> Class<?> beanClass = ((AbstractBeanDefinition) beanDef).getBeanClass(); //class org.springframework.context.annotation.ConfigurationClassPostProcessor
                                                                                    --> metadata = new StandardAnnotationMetadata(beanClass, true);
                                                                                        --> org.springframework.core.type.StandardAnnotationMetadata.StandardAnnotationMetadata(java.lang.Class<?>, boolean)
                                                                                            --> super(introspectedClass);
                                                                                                --> org.springframework.core.type.StandardClassMetadata.StandardClassMetadata
                                                                                                    --> this.introspectedClass = introspectedClass; //class org.springframework.context.annotation.ConfigurationClassPostProcessor
                                                                                            --> this.annotations = introspectedClass.getAnnotations(); //[]
                                                                                            --> this.nestedAnnotationsAsMap = nestedAnnotationsAsMap; // true

                                                                                        //判断是强config还是弱config
                                                                                    --> private static final Set<String> candidateIndicators = new HashSet<>(8);
                                                                                    --> candidateIndicators.add(Component.class.getName());
                                                                                        candidateIndicators.add(ComponentScan.class.getName());
                                                                                        candidateIndicators.add(Import.class.getName());
                                                                                        candidateIndicators.add(ImportResource.class.getName());

                                                                                        //如果直接标注Configuration，就是强config
                                                                                    --> if (isFullConfigurationCandidate(metadata))
                                                                                        --> return metadata.isAnnotated(Configuration.class.getName());

                                                                                        --> CONFIGURATION_CLASS_ATTRIBUTE = Conventions.getQualifiedAttributeName(ConfigurationClassPostProcessor.class, "configurationClass");
                                                                                        --> CONFIGURATION_CLASS_FULL = full
                                                                                        --> beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
                                                                                        --> return true

                                                                                        //如果标注了Import之类的，就是弱config
                                                                                    --> if (isLiteConfigurationCandidate(metadata))
                                                                                        --> for (String indicator : candidateIndicators)
                                                                                            --> if (metadata.isAnnotated(indicator))
                                                                                                --> return true

                                                                                    --> else
                                                                                        --> return metadata.hasAnnotatedMethods(Bean.class.getName());


                                                                            --> if (isConfig)
                                                                                --> configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));

                                                            --> SingletonBeanRegistry sbr = (SingletonBeanRegistry) registry;
                                                            --> BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton("org.springframework.context.annotation.internalConfigurationBeanNameGenerator");

                                                                // Parse each @Configuration class
                                                            --> ConfigurationClassParser parser = new ConfigurationClassParser(
                                                                				this.metadataReaderFactory, this.problemReporter, this.environment,
                                                                				this.resourceLoader, this.componentScanBeanNameGenerator, registry);
                                                                --> org.springframework.context.annotation.ConfigurationClassParser
                                                                    --> this.metadataReaderFactory = metadataReaderFactory;
                                                                    --> this.problemReporter = problemReporter;
                                                                    --> this.environment = environment;
                                                                    --> this.resourceLoader = resourceLoader;
                                                                    --> this.registry = registry;
                                                                    --> this.componentScanParser = new ComponentScanAnnotationParser(environment, resourceLoader, componentScanBeanNameGenerator, registry);
                                                                        --> org.springframework.context.annotation.ComponentScanAnnotationParser.ComponentScanAnnotationParser
                                                                            --> this.environment = environment;
                                                                                this.resourceLoader = resourceLoader;
                                                                                this.beanNameGenerator = beanNameGenerator;
                                                                                this.registry = registry;

                                                                    --> this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader);
                                                                        --> org.springframework.context.annotation.ConditionEvaluator.ConditionEvaluator
                                                                            --> this.context = new ConditionContextImpl(registry, environment, resourceLoader);
                                                                                --> this.registry = registry;
                                                                                    this.beanFactory = deduceBeanFactory(registry);
                                                                                    this.environment = (environment != null ? environment : deduceEnvironment(registry));
                                                                                    this.resourceLoader = (resourceLoader != null ? resourceLoader : deduceResourceLoader(registry));
                                                                                    this.classLoader = deduceClassLoader(resourceLoader, this.beanFactory);

                                                            --> Set<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates); //此时现在里面有个 bootstrapImportSelectorConfiguration
                                                            --> Set<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());

                                                            --> parser.parse(candidates);
                                                                --> org.springframework.context.annotation.ConfigurationClassParser.parse(java.util.Set<org.springframework.beans.factory.config.BeanDefinitionHolder>)
                                                                    --> BeanDefinition bd = holder.getBeanDefinition();
                                                                    --> parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
                                                                        --> ConfigurationClass configurationClass = new ConfigurationClass(metadata, beanName)
                                                                            --> org.springframework.context.annotation.ConfigurationClass.ConfigurationClass(org.springframework.core.type.AnnotationMetadata, java.lang.String)
                                                                                --> this.metadata = metadata;
                                                                                    this.resource = new DescriptiveResource(metadata.getClassName());
                                                                                    this.beanName = beanName;

                                                                        --> processConfigurationClass(configurationClass);
                                                                            --> ConfigurationClass existingClass = this.configurationClasses.get(configClass);
                                                                            --> SourceClass sourceClass = asSourceClass(configClass);
                                                                            --> sourceClass = doProcessConfigurationClass(configClass, sourceClass);
                                                                                --> if (configClass.getMetadata().isAnnotated(Component.class.getName()))
                                                                                        // Recursively process any member (nested) classes first
                                                                                    --> processMemberClasses(configClass, sourceClass);
                                                                                        --> org.springframework.context.annotation.ConfigurationClassParser.processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass)
                                                                                            --> Collection<SourceClass> memberClasses = sourceClass.getMemberClasses();
                                                                                                --> Object sourceToProcess = this.source;
                                                                                                --> Class<?> sourceClass = (Class<?>) sourceToProcess;
                                                                                                --> Class<?>[] declaredClasses = sourceClass.getDeclaredClasses();
                                                                                                --> List<SourceClass> members = new ArrayList<>(declaredClasses.length);
                                                                                                --> members.add(asSourceClass(declaredClass));
                                                                                                --> return members;

                                                                                        // Process any @ComponentScan annotations
                                                                                    --> Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);

                                                                                        // Process any @Import annotations
                                                                                    --> Set<SourceClass> set = getImports(sourceClass)
                                                                                            // 存放@Import注解标记的类
                                                                                        --> Set<SourceClass> imports = new LinkedHashSet<>();
                                                                                            //存放除了@Import，并且不是java包开头的注解的类
                                                                                        --> Set<SourceClass> visited = new LinkedHashSet<>();
                                                                                            // sourceClass = org.springframework.cloud.bootstrap.BootstrapImportSelectorConfiguration,这里要处理这个类上面的注解
                                                                                        --> collectImports(sourceClass, imports, visited);
                                                                                            --> for (SourceClass annotation : sourceClass.getAnnotations())
                                                                                                --> String annName = annotation.getMetadata().getClassName(); //org.springframework.context.annotation.Configuration
                                                                                                --> if (!annName.startsWith("java") && !annName.equals(Import.class.getName()))
                                                                                                        // 将@Configuration中所有的注解都扫描一下，将非java开头的注解都添加到visited中，循环完之后里面有[org.springframework.cloud.bootstrap.BootstrapImportSelectorConfiguration,org.springframework.context.annotation.Configuration,org.springframework.stereotype.Component,org.springframework.stereotype.Indexed]
                                                                                                    --> collectImports(annotation, imports, visited);

                                                                                                --> String annName = annotation.getMetadata().getClassName(); // org.springframework.context.annotation.Import

                                                                                                        //获取@Import注解的value值，这里获取的是org.springframework.cloud.bootstrap.BootstrapImportSelector
                                                                                                    --> imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), "value"));


                                                                                        --> return imports;

                                                                                        //configClass = ConfigurationClass: beanName 'bootstrapImportSelectorConfiguration', org.springframework.cloud.bootstrap.BootstrapImportSelectorConfiguration;
                                                                                        //sourceClass = org.springframework.cloud.bootstrap.BootstrapImportSelectorConfiguration;
                                                                                        //set = org.springframework.cloud.bootstrap.BootstrapImportSelector
                                                                                    --> processImports(configClass, sourceClass, set, true);
                                                                                        --> if (candidate.isAssignable(ImportSelector.class))
                                                                                                // Candidate class is an ImportSelector -> delegate to it to determine imports
                                                                                            --> Class<?> candidateClass = candidate.loadClass();  //class org.springframework.cloud.bootstrap.BootstrapImportSelector
                                                                                            --> ImportSelector selector = BeanUtils.instantiateClass(candidateClass, ImportSelector.class);
                                                                                            --> ParserStrategyUtils.invokeAwareMethods(selector, this.environment, this.resourceLoader, this.registry);
                                                                                            --> if (selector instanceof DeferredImportSelector)
                                                                                                --> org.springframework.context.annotation.ConfigurationClassParser.DeferredImportSelectorHandler.handle(ConfigurationClass configClass, DeferredImportSelector importSelector)
                                                                                                    --> DeferredImportSelectorHolder holder = new DeferredImportSelectorHolder(configClass, importSelector);
                                                                                                        --> this.configurationClass = configClass;
                                                                                                        --> this.importSelector = selector;
                                                                                                    --> this.deferredImportSelectors.add(holder);

                                                                                        // Process any @ImportResource annotations
                                                                                    --> AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);

                                                                                        // Process individual @Bean methods
                                                                                    --> Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);

                                                                                        // Process default methods on interfaces
                                                                                    --> processInterfaces(configClass, sourceClass); //sourceClass = org.springframework.cloud.bootstrap.BootstrapImportSelectorConfiguration 没有实现接口

                                                                                        // Process superclass, if any
                                                                                    --> if (sourceClass.getMetadata().hasSuperClass())
                                                                                        --> String superclass = sourceClass.getMetadata().getSuperClassName();

                                                                                    --> return null;

                                                                            --> this.configurationClasses.put(configClass, configClass);

                                                                --> this.deferredImportSelectorHandler.process();
                                                                    --> org.springframework.context.annotation.ConfigurationClassParser.DeferredImportSelectorHandler.process
                                                                        --> List<DeferredImportSelectorHolder> deferredImports = this.deferredImportSelectors;
                                                                        --> DeferredImportSelectorGroupingHandler handler = new DeferredImportSelectorGroupingHandler();
                                                                            --> private final Map<Object, DeferredImportSelectorGrouping> groupings = new LinkedHashMap<>();
                                                                            --> private final Map<AnnotationMetadata, ConfigurationClass> configurationClasses = new HashMap<>();

                                                                        --> deferredImports.sort(DEFERRED_IMPORT_COMPARATOR);
                                                                        --> deferredImports.forEach(handler::register);
                                                                            --> org.springframework.context.annotation.ConfigurationClassParser.DeferredImportSelectorGroupingHandler.register(DeferredImportSelectorHolder deferredImport)
                                                                                --> Class<? extends Group> group = deferredImport.getImportSelector().getImportGroup();
                                                                                    --> return null
                                                                                --> DeferredImportSelectorGrouping grouping = this.groupings.computeIfAbsent((group != null ? group : deferredImport), key -> new DeferredImportSelectorGrouping(createGroup(group)));
                                                                                    --> this.group = group;

                                                                                --> grouping.add(deferredImport);
                                                                                --> this.configurationClasses.put(deferredImport.getConfigurationClass().getMetadata(),deferredImport.getConfigurationClass());

                                                                        --> handler.processGroupImports();

                                                                //验证配置类是不是final，是不是static的，是不是Overridable的
                                                            --> parser.validate();

                                                            --> Set<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());
                                                            --> configClasses.removeAll(alreadyParsed);

                                                            --> this.reader = new ConfigurationClassBeanDefinitionReader(
                                                                						registry, this.sourceExtractor, this.resourceLoader, this.environment,
                                                                						this.importBeanNameGenerator, parser.getImportRegistry());
                                                                --> this.registry = registry;
                                                                    this.sourceExtractor = sourceExtractor;
                                                                    this.resourceLoader = resourceLoader;
                                                                    this.environment = environment;
                                                                    this.importBeanNameGenerator = importBeanNameGenerator;
                                                                    this.importRegistry = importRegistry;
                                                                    this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader);

                                                            --> this.reader.loadBeanDefinitions(configClasses);
                                                                --> for (ConfigurationClass configClass : configurationModel)
                                                                    --> loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);
                                                                        --> registerBeanDefinitionForImportedConfigurationClass(configClass);
                                                                            --> AnnotationMetadata metadata = configClass.getMetadata();
                                                                            --> AnnotatedGenericBeanDefinition configBeanDef = new AnnotatedGenericBeanDefinition(metadata);
                                                                            --> ScopeMetadata scopeMetadata = scopeMetadataResolver.resolveScopeMetadata(configBeanDef);
                                                                                --> ScopeMetadata metadata = new ScopeMetadata();
                                                                                --> metadata.setScopeName(attributes.getString("value"));
                                                                                --> ScopedProxyMode proxyMode = attributes.getEnum("proxyMode");
                                                                                --> metadata.setScopedProxyMode(proxyMode);
                                                                                --> return metadata;

                                                                            --> configBeanDef.setScope(scopeMetadata.getScopeName()); //singleton
                                                                            --> String configBeanName = this.importBeanNameGenerator.generateBeanName(configBeanDef, this.registry);
                                                                                //处理一些公共的注解，比如@Primary，@Lazy等
                                                                            --> AnnotationConfigUtils.processCommonDefinitionAnnotations(configBeanDef, metadata);

                                                                            --> BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(configBeanDef, configBeanName);
                                                                            --> definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
                                                                                --> ScopedProxyMode scopedProxyMode = metadata.getScopedProxyMode();
                                                                                --> return definition;

                                                                                //和之前注册beanDefition相同
                                                                            --> this.registry.registerBeanDefinition(definitionHolder.getBeanName(), definitionHolder.getBeanDefinition());
                                                                            --> configClass.setBeanName(configBeanName);

                                                                        --> loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
                                                                            --> Map<Class<?>, BeanDefinitionReader> readerInstanceCache = new HashMap<>();
                                                                            --> readerInstanceCache.put(readerClass, reader);
                                                                            --> reader.loadBeanDefinitions(resource);

                                                                        --> loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
                                                                            --> registrars.forEach((registrar, metadata) ->
                                                                                				registrar.registerBeanDefinitions(metadata, this.registry));


                                                            --> alreadyParsed.addAll(configClasses);

                                                            --> sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
                                                                --> super.registerSingleton(beanName, singletonObject);
                                                                    --> addSingleton(beanName, singletonObject);
                                                                        --> this.singletonObjects.put(beanName, singletonObject);
                                                                            this.singletonFactories.remove(beanName);
                                                                            this.earlySingletonObjects.remove(beanName);
                                                                            this.registeredSingletons.add(beanName);

                                                                --> Set<String> updatedSingletons = new LinkedHashSet<>(this.manualSingletonNames.size() + 1);
                                                                    updatedSingletons.addAll(this.manualSingletonNames);
                                                                    updatedSingletons.add(beanName);
                                                                    this.manualSingletonNames = updatedSingletons;


                                                        // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
                                                    --> postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
                                                        --> return doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit);
                                                            --> List<String> result = new ArrayList<>();
                                                            --> for (String beanName : this.beanDefinitionNames)
                                                                --> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
                                                                    --> return getMergedBeanDefinition(beanName, getBeanDefinition(beanName));
                                                                --> result.add(beanName);
                                                            --> return StringUtils.toStringArray(result);

                                                    --> registryProcessors.addAll(currentRegistryProcessors);

                                                    --> invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
                                                        --> org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors
                                                            --> for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors)
                                                                --> postProcessor.postProcessBeanDefinitionRegistry(registry);

                                                        // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
                                                    --> postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); //org.springframework.context.annotation.internalConfigurationAnnotationProcessor

                                                    --> invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);

                                                        // Now, invoke the postProcessBeanFactory callback of all processors handled so far.
                                                    --> invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
                                                        --> for (BeanFactoryPostProcessor postProcessor : postProcessors)
                                                            --> postProcessor.postProcessBeanFactory(beanFactory);


                                                    --> invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
                                                        --> for (BeanFactoryPostProcessor postProcessor : postProcessors)
                                                            --> postProcessor.postProcessBeanFactory(beanFactory);

                                                    --> String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);

                                                        // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
                                                        // Ordered, and the rest.
                                                    --> List<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();
                                                    --> List<String> orderedPostProcessorNames = new ArrayList<>();
                                                    --> List<String> nonOrderedPostProcessorNames = new ArrayList<>();

                                                        // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
                                                    --> invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);

                                                        // Next, invoke the BeanFactoryPostProcessors that implement Ordered.
                                                    --> invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);

                                                        // Finally, invoke all other BeanFactoryPostProcessors.
                                                    --> invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);


                                        // Register bean processors that intercept bean creation.
                                    --> registerBeanPostProcessors(beanFactory);
                                        --> PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);

                                                //从beanDefinitionNames集合中找到对应类型的类
                                            --> String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);

                                            --> beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));
                                                --> this.beanFactory = beanFactory;
                                                    this.beanPostProcessorTargetCount = beanPostProcessorTargetCount;
                                            --> List<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();
                                                List<BeanPostProcessor> internalPostProcessors = new ArrayList<>();
                                                List<String> orderedPostProcessorNames = new ArrayList<>();
                                                List<String> nonOrderedPostProcessorNames = new ArrayList<>();

                                            --> registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);
                                            --> registerBeanPostProcessors(beanFactory, orderedPostProcessors);
                                            --> registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);
                                            --> registerBeanPostProcessors(beanFactory, internalPostProcessors);
                                            --> beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));

                                        // Initialize message source for this context.
                                    --> initMessageSource();
                                        --> ConfigurableListableBeanFactory beanFactory = getBeanFactory();
                                        --> DelegatingMessageSource dms = new DelegatingMessageSource();
                                        --> dms.setParentMessageSource(getInternalParentMessageSource());
                                        --> beanFactory.registerSingleton("messageSource", this.messageSource);

                                        // Initialize event multicaster for this context.
                                    --> initApplicationEventMulticaster();
                                        --> ConfigurableListableBeanFactory beanFactory = getBeanFactory();
                                        --> this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);
                                            --> setBeanFactory(beanFactory);
                                                --> this.beanFactory = beanFactory;
                                                --> this.beanClassLoader = cbf.getBeanClassLoader();
                                                --> this.retrievalMutex = cbf.getSingletonMutex();

                                        --> beanFactory.registerSingleton("applicationEventMulticaster", this.applicationEventMulticaster);

                                        // Initialize other special beans in specific context subclasses.
                                    --> onRefresh(); // 空方法

                                        // Check for listener beans and register them.
                                    --> registerListeners();
                                        --> for (ApplicationListener<?> listener : getApplicationListeners()) //循环之前扫描出来的监听器
                                            --> getApplicationEventMulticaster().addApplicationListener(listener)
                                                --> Object singletonTarget = AopProxyUtils.getSingletonTarget(listener);
                                                    --> TargetSource targetSource = ((Advised)candidate).getTargetSource();
                                                    --> return ((SingletonTargetSource)targetSource).getTarget();

                                                --> this.defaultRetriever.applicationListeners.add(listener);

                                            //获取所有的ApplicationListener的类
                                        --> String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);

                                        --> Set<ApplicationEvent> earlyEventsToProcess = this.earlyApplicationEvents;

                                        --> getApplicationEventMulticaster().multicastEvent(earlyEvent);


                                        // Instantiate all remaining (non-lazy-init) singletons.
                                    --> finishBeanFactoryInitialization(beanFactory);
                                        --> String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
                                        --> beanFactory.setTempClassLoader(null);
                                        --> eanFactory.freezeConfiguration();
                                            --> this.configurationFrozen = true;
                                                this.frozenBeanDefinitionNames = StringUtils.toStringArray(this.beanDefinitionNames);

                                            //处理先初始化的bean
                                        --> beanFactory.preInstantiateSingletons();


                                        // Last step: publish corresponding event.
                                    --> finishRefresh();
                                            // Clear context-level resource caches (such as ASM metadata from scanning).
                                        --> clearResourceCaches();

                                            // Initialize lifecycle processor for this context.
                                        --> initLifecycleProcessor();
                                            --> ConfigurableListableBeanFactory beanFactory = getBeanFactory();
                                            --> DefaultLifecycleProcessor defaultProcessor = new DefaultLifecycleProcessor();
                                            --> defaultProcessor.setBeanFactory(beanFactory);
                                            --> this.lifecycleProcessor = defaultProcessor;
                                            --> beanFactory.registerSingleton("lifecycleProcessor", this.lifecycleProcessor);

                                            // Propagate refresh to lifecycle processor first.
                                        --> getLifecycleProcessor().onRefresh();
                                            --> startBeans(true);

                                                --> Map<String, Lifecycle> lifecycleBeans = getLifecycleBeans();
                                                    --> ConfigurableListableBeanFactory beanFactory = getBeanFactory();
                                                    --> Map<String, Lifecycle> beans = new LinkedHashMap<>();
                                                    --> String[] beanNames = beanFactory.getBeanNamesForType(Lifecycle.class, false, false);
                                                    --> String beanNameToRegister = BeanFactoryUtils.transformedBeanName(beanName); //lifecycleProcessor
                                                    --> boolean isFactoryBean = beanFactory.isFactoryBean(beanNameToRegister);
                                                    --> String beanNameToCheck = (isFactoryBean ? BeanFactory.FACTORY_BEAN_PREFIX + beanName : beanName); //lifecycleProcessor

                                                    --> Object bean = beanFactory.getBean(beanNameToCheck);
                                                    --> beans.put(beanNameToRegister, (Lifecycle) bean);
                                                    --> return beans;

                                                --> Map<Integer, LifecycleGroup> phases = new HashMap<>();

                                                --> phases.get(key).start();
                                                        //Start the specified bean as part of the given set of Lifecycle beans,
                                                        //making sure that any beans that it depends on are started first.
                                                    --> doStart(this.lifecycleBeans, member.name, this.autoStartupOnly);
                                                        --> Lifecycle bean = lifecycleBeans.remove(beanName);
                                                        --> bean.start();
                                                            --> getLifecycleProcessor().start();
                                                                publishEvent(new ContextStartedEvent(this));

                                            --> this.running = true;

                                            // Publish the final event.
                                        --> publishEvent(new ContextRefreshedEvent(this));
                                            --> publishEvent(event, null);
                                                --> applicationEvent = (ApplicationEvent) event;

                                                    //启动listener
                                                --> getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);


                                            // Participate in LiveBeansView MBean, if active.
                                        --> LiveBeansView.registerApplicationContext(this);
                                            --> String mbeanDomain = applicationContext.getEnvironment().getProperty("spring.liveBeansView.mbeanDomain");
                                            --> MBeanServer server = ManagementFactory.getPlatformMBeanServer();
                                            --> applicationName = applicationContext.getApplicationName();
                                            --> server.registerMBean(new LiveBeansView(),new ObjectName(mbeanDomain, MBEAN_APPLICATION_KEY, applicationName));
                                            --> applicationContexts.add(applicationContext);

                        //查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。
                    --> afterRefresh(context, applicationArguments);
                        --> 空方法

                    --> if (this.logStartupInfo)
                        --> new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);

                    --> listeners.started(context);
                        --> for (SpringApplicationRunListener listener : this.listeners) //EventPublishingRunListener
                            --> listener.started(context);
                                --> context.publishEvent(new ApplicationStartedEvent(this.application, this.args, context));

                    --> callRunners(context, applicationArguments);
                        --> List<Object> runners = new ArrayList<>();
                        --> runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());
                        --> runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());

                    --> listeners.running(context);
                        --> for (SpringApplicationRunListener listener : this.listeners)
                            --> listener.running(context);
                                --> context.publishEvent(new ApplicationReadyEvent(this.application, this.args, context));

                    --> return context;

            --> return context


            //上面执行完成之后 发布消息触发listener开始执行

            //它是用ApplicationContextInitializer beans通过一个单独的引导环境去准备SpringApplication。
            //这个引导上下文是从spring.factories源中作为BootstrapConfiguration创建的SpringApplication，
            //并且用外部的文件如"bootstrap.properties"或 yml 初始化 ，而不是普通的application.properties
        --> org.springframework.cloud.bootstrap.BootstrapApplicationListener.onApplicationEvent(ApplicationEnvironmentPreparedEvent event)
            --> ConfigurableEnvironment environment = event.getEnvironment();

                // 你可以通过设置`spring.cloud.bootstrap.enabled=false`来禁用`bootstrap`
            --> if (!environment.getProperty("spring.cloud.bootstrap.enabled", Boolean.class,true))

            --> if (environment.getPropertySources().contains("bootstrap"))

            --> ConfigurableApplicationContext context = null;
            --> String configName = environment.resolvePlaceholders("${spring.cloud.bootstrap.name:bootstrap}"); // bootstrap
            --> for (ApplicationContextInitializer<?> initializer : event.getSpringApplication().getInitializers()) //就是从spring.factories里面读取的那六个ContextInitializer
                --> if (initializer instanceof ParentContextApplicationContextInitializer) //六个都不是

            --> context = bootstrapServiceContext(environment, event.getSpringApplication(),configName);
                --> org.springframework.cloud.bootstrap.BootstrapApplicationListener.bootstrapServiceContext(ConfigurableEnvironment environment, final SpringApplication application,String configName)
                    --> StandardEnvironment bootstrapEnvironment = new StandardEnvironment();
                    --> MutablePropertySources bootstrapProperties = bootstrapEnvironment.getPropertySources();
                    --> String configLocation = environment.resolvePlaceholders("${spring.cloud.bootstrap.location:}");
                    --> Map<String, Object> bootstrapMap = new HashMap<>();
                    --> bootstrapMap.put("spring.config.name", configName); // bootstrap

                    --> bootstrapMap.put("spring.main.web-application-type", "none");
                    --> bootstrapMap.put("spring.config.location", configLocation);

                    --> bootstrapProperties.addFirst(new MapPropertySource("bootstrap", bootstrapMap)); //[MapPropertySource {name='bootstrap'}, MapPropertySource {name='systemProperties'}, SystemEnvironmentPropertySource {name='systemEnvironment'}]

                    --> SpringApplicationBuilder builder = new SpringApplicationBuilder()
                                        .profiles(environment.getActiveProfiles()).bannerMode(Mode.OFF)
                                        .environment(bootstrapEnvironment)
                                        // Don't use the default properties in this builder
                                        .registerShutdownHook(false).logStartupInfo(false)
                                        .web(WebApplicationType.NONE);

                    --> final SpringApplication builderApplication = builder.application();
                        --> return this.application;

                    --> builder.sources(BootstrapImportSelectorConfiguration.class);

                    --> final ConfigurableApplicationContext context = builder.run();
                        --> org.springframework.boot.builder.SpringApplicationBuilder.run
                                //如果父类是空，则自己就是父类，不执行
                            --> configureAsChildIfNecessary(args);
                            --> SpringApplication springApplication = build();
                                --> return build(new String[0]);
                                    --> this.application.addPrimarySources(this.sources); //source = class org.springframework.cloud.bootstrap.BootstrapImportSelectorConfiguration
                                    --> return this.application;

                                //和之前的run的逻辑是相同的
                            --> this.context = springApplication.run(args);
                                --> ConfigurableApplicationContext context = null;
                                --> configureHeadlessProperty();
                                --> SpringApplicationRunListeners listeners = getRunListeners(args);
                                --> listeners.starting();
                                --> ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
                                --> ConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments);
                                --> configureIgnoreBeanInfo(environment);
                                --> Banner printedBanner = printBanner(environment);
                                --> context = createApplicationContext();
                                --> prepareContext(context, environment, listeners, applicationArguments,printedBanner);
                                --> refreshContext(context);
                                --> afterRefresh(context, applicationArguments);
                                --> listeners.started(context);
                                --> callRunners(context, applicationArguments);
                                --> listeners.running(context);
                                --> return context;

                    --> context.setId("bootstrap");

                        // Make the bootstrap context a parent of the app context
                    --> addAncestorInitializer(application, context);
                        --> application.addInitializers(new AncestorInitializer(context));

                    --> mergeDefaultProperties(environment.getPropertySources(), bootstrapProperties);
                    --> return context;

            --> event.getSpringApplication().addListeners(new CloseContextOnFailureApplicationListener(context));

            --> apply(context, event.getSpringApplication(), environment);
                --> org.springframework.cloud.bootstrap.BootstrapApplicationListener.apply
                    --> List<ApplicationContextInitializer> initializers = getOrderedBeansOfType(context,ApplicationContextInitializer.class);
                        --> List<T> result = new ArrayList<T>();
                        --> for (String name : context.getBeanNamesForType(type)) //interface org.springframework.context.ApplicationContextInitializer
                            --> result.add(context.getBean(name, type))
                        --> return result;

                    --> application.addInitializers(initializers.toArray(new ApplicationContextInitializer[initializers.size()]));

                    --> addBootstrapDecryptInitializer(application);
                        --> DelegatingEnvironmentDecryptApplicationInitializer decrypter = null;
                        --> if (ini instanceof EnvironmentDecryptApplicationInitializer)
                            --> ApplicationContextInitializer del = (ApplicationContextInitializer) ini;
                        --> decrypter = new DelegatingEnvironmentDecryptApplicationInitializer(del);
                            --> this.delegate = delegate;

                        --> application.addInitializers(decrypter);


            //这次就开始扫描feignClient了,这次容器里面把class org.springframework.cloud.bootstrap.BootstrapImportSelectorConfiguration类给弄成bean了
        --> org.springframework.boot.SpringApplication.run(java.lang.String...)
            --> ConfigurableApplicationContext context = null;
            --> configureHeadlessProperty();
            --> SpringApplicationRunListeners listeners = getRunListeners(args);
            --> listeners.starting();
            --> ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
            --> ConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments);
            --> configureIgnoreBeanInfo(environment);
            --> Banner printedBanner = printBanner(environment);
            --> context = createApplicationContext();
            --> prepareContext(context, environment, listeners, applicationArguments,printedBanner);
            --> refreshContext(context);
                --> refresh(context);
                    --> ((AbstractApplicationContext) applicationContext).refresh();
                        --> super.refresh();  //这个解析和之前相同
                                //有一处不一样，currentRegistryProcessors = ConfigurationClassPostProcessor
                            --> invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
                                --> postProcessor.postProcessBeanDefinitionRegistry(registry);
                                    --> org.springframework.context.annotation.ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry
                                        --> processConfigBeanDefinitions(registry);
                                            --> List<BeanDefinitionHolder> configCandidates = new ArrayList<>();
                                                //[
                                                    org.springframework.context.annotation.internalConfigurationAnnotationProcessor
                                                    org.springframework.context.annotation.internalAutowiredAnnotationProcessor
                                                    org.springframework.context.annotation.internalCommonAnnotationProcessor
                                                    org.springframework.context.event.internalEventListenerProcessor
                                                    org.springframework.context.event.internalEventListenerFactory
                                                    org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory
                                                    bootstrapApplication
                                                //]
                                            --> String[] candidateNames = registry.getBeanDefinitionNames();
                                            --> for (String beanName : candidateNames)
                                                --> configCandidates.add(new BeanDefinitionHolder(beanDef, beanName)); //class com.liang.BootstrapApplication

                                                // Parse each @Configuration class
                                            --> ConfigurationClassParser parser = new ConfigurationClassParser(
                                                				this.metadataReaderFactory, this.problemReporter, this.environment,
                                                				this.resourceLoader, this.componentScanBeanNameGenerator, registry);

                                                --> this.metadataReaderFactory = metadataReaderFactory;
                                                    this.problemReporter = problemReporter;
                                                    this.environment = environment;
                                                    this.resourceLoader = resourceLoader;
                                                    this.registry = registry;
                                                    this.componentScanParser = new ComponentScanAnnotationParser(environment, resourceLoader, componentScanBeanNameGenerator, registry);
                                                        --> this.environment = environment;
                                                            this.resourceLoader = resourceLoader;
                                                            this.beanNameGenerator = beanNameGenerator;
                                                            this.registry = registry;

                                                    this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader);
                                                        --> this.context = new ConditionContextImpl(registry, environment, resourceLoader);
                                                            --> this.registry = registry;
                                                                this.beanFactory = deduceBeanFactory(registry);
                                                                this.environment = (environment != null ? environment : deduceEnvironment(registry));
                                                                this.resourceLoader = (resourceLoader != null ? resourceLoader : deduceResourceLoader(registry));
                                                                this.classLoader = deduceClassLoader(resourceLoader, this.beanFactory);

                                            --> parser.parse(candidates);
                                                --> BeanDefinition bd = holder.getBeanDefinition()
                                                --> parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());
                                                    --> processConfigurationClass(new ConfigurationClass(metadata, beanName));
                                                        --> ConfigurationClass existingClass = this.configurationClasses.get(configClass);
                                                        --> SourceClass sourceClass = asSourceClass(configClass); //ConfigurationClass: beanName 'bootstrapApplication', com.liang.BootstrapApplication
                                                        --> sourceClass = doProcessConfigurationClass(configClass, sourceClass);
                                                            --> org.springframework.context.annotation.ConfigurationClassParser.doProcessConfigurationClass
                                                                --> if (configClass.getMetadata().isAnnotated(Component.class.getName()))
                                                                    --> processMemberClasses(configClass, sourceClass);
                                                                        --> Collection<SourceClass> memberClasses = sourceClass.getMemberClasses(); // 空的，代码不执行

                                                                    //启动类上标注了@SpringBootApplication，里面有@ComponentScan
                                                                --> Set<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);

                                                                    --> Set<BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
                                                                        --> org.springframework.context.annotation.ComponentScanAnnotationParser.parse
                                                                            --> ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry,componentScan.getBoolean("useDefaultFilters"), this.environment, this.resourceLoader);
                                                                            --> Class<? extends BeanNameGenerator> generatorClass = componentScan.getClass("nameGenerator");
                                                                            --> scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator : BeanUtils.instantiateClass(generatorClass));
                                                                            --> ScopedProxyMode scopedProxyMode = componentScan.getEnum("scopedProxy"); // ScopedProxyMode.DEFAULT
                                                                            --> Class<? extends ScopeMetadataResolver> resolverClass = componentScan.getClass("scopeResolver");
                                                                            --> scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));
                                                                            --> scanner.setResourcePattern(componentScan.getString("resourcePattern")); // **/*.class
                                                                            --> scanner.addExcludeFilter(typeFilter);
                                                                            --> Set<String> basePackages = new LinkedHashSet<>();
                                                                            --> String[] basePackagesArray = componentScan.getStringArray("basePackages"); //没手动指定就是空的
                                                                            --> basePackages.add(ClassUtils.getPackageName(declaringClass)); // com.liang
                                                                            --> return scanner.doScan(StringUtils.toStringArray(basePackages));
                                                                                --> org.springframework.context.annotation.ClassPathBeanDefinitionScanner.doScan
                                                                                    --> Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>();
                                                                                    --> Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
                                                                                        --> org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents
                                                                                            --> return scanCandidateComponents(basePackage);
                                                                                                --> Set<BeanDefinition> candidates = new LinkedHashSet<>();
                                                                                                --> String packageSearchPath = "classpath*:" + resolveBasePackage("com.liang") + '/' + "**/*.class";     //classpath*:com/liang/**/*.class
                                                                                                --> Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);
                                                                                                    --> org.springframework.context.support.GenericApplicationContext.getResources
                                                                                                        --> return super.getResources(locationPattern); //classpath*:com/liang/**/*.class
                                                                                                            --> org.springframework.context.support.AbstractApplicationContext.getResources
                                                                                                                --> return this.resourcePatternResolver.getResources(locationPattern);
                                                                                                                    --> org.springframework.core.io.support.PathMatchingResourcePatternResolver.getResources
                                                                                                                        --> return findPathMatchingResources(locationPattern);
                                                                                                                            --> String rootDirPath = determineRootDir(locationPattern);//locationPattern =  classpath*:com/liang/**/*.class; rootDirPath = classpath*:com/liang/
                                                                                                                            --> String subPattern = locationPattern.substring(rootDirPath.length()); //**/*.class
                                                                                                                            --> Resource[] rootDirResources = getResources(rootDirPath);
                                                                                                                                --> return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));
                                                                                                                                    --> String path = location; //com/liang/
                                                                                                                                    --> Set<Resource> result = doFindAllClassPathResources(path);
                                                                                                                                        --> Set<Resource> result = new LinkedHashSet<>(16);
                                                                                                                                        --> ClassLoader cl = getClassLoader();
                                                                                                                                        --> Enumeration<URL> resourceUrls = (cl != null ? cl.getResources(path) : ClassLoader.getSystemResources(path));
                                                                                                                                            -->
                                                                                                                                        --> URL url = resourceUrls.nextElement(); //file:/Users/liang/workspace/ideaWorkspace/tut/feign/liang-openfeign/target/classes/com/liang/
                                                                                                                                        --> result.add(convertClassLoaderURL(url));
                                                                                                                                            --> return new UrlResource(url);
                                                                                                                                                --> this.url = url;

                                                                                                                                        --> return result; // URL [file:/Users/liang/workspace/ideaWorkspace/tut/feign/liang-openfeign/target/classes/com/liang/]

                                                                                                                                    --> return result.toArray(new Resource[0]);

                                                                                                                            --> Set<Resource> result = new LinkedHashSet<>(16);
                                                                                                                            --> rootDirResource = resolveRootDirResource(rootDirResource);
                                                                                                                                --> return original;
                                                                                                                            --> URL rootDirUrl = rootDirResource.getURL(); //file:/Users/liang/workspace/ideaWorkspace/tut/feign/liang-openfeign/target/classes/com/liang/

                                                                                                                            --> result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern)); //rootDirResource = URL [file:/Users/liang/workspace/ideaWorkspace/tut/feign/liang-openfeign/target/classes/com/liang/]; subPattern= **/*.class
                                                                                                                                --> return super.doFindPathMatchingFileResources(rootDirResource, subPattern);
                                                                                                                                    --> org.springframework.core.io.support.PathMatchingResourcePatternResolver.doFindPathMatchingFileResources
                                                                                                                                            //获取了com/liang目录
                                                                                                                                        --> rootDir = rootDirResource.getFile().getAbsoluteFile(); // /Users/liang/workspace/ideaWorkspace/tut/feign/liang-openfeign/target/classes/com/liang
                                                                                                                                        --> return doFindMatchingFileSystemResources(rootDir, subPattern);
                                                                                                                                            --> Set<File> matchingFiles = retrieveMatchingFiles(rootDir, subPattern);
                                                                                                                                                --> String fullPattern = StringUtils.replace(rootDir.getAbsolutePath(), File.separator, "/"); ///Users/liang/workspace/ideaWorkspace/tut/feign/liang-openfeign/target/classes/com/liang
                                                                                                                                                --> fullPattern = fullPattern + StringUtils.replace(pattern, File.separator, "/");  // /Users/liang/workspace/ideaWorkspace/tut/feign/liang-openfeign/target/classes/com/liang/**/*.class
                                                                                                                                                --> Set<File> result = new LinkedHashSet<>(8);
                                                                                                                                                --> doRetrieveMatchingFiles(fullPattern, rootDir, result); // 扫描了全部的class文件
                                                                                                                                                --> return result;

                                                                                                                                            --> Set<Resource> result = new LinkedHashSet<>(matchingFiles.size());
                                                                                                                                            --> result.add(new FileSystemResource(file));
                                                                                                                                            --> return result;

                                                                                                                            --> return result.toArray(new Resource[0]);

                                                                                                    //扫描class文件，找出被Component标记的类，生成对应的BeanDefinition
                                                                                                --> for (Resource resource : resources)
                                                                                                    --> MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);
                                                                                                        --> return new SimpleMetadataReader(resource, this.resourceLoader.getClassLoader());
                                                                                                            --> AnnotationMetadataReadingVisitor visitor = new AnnotationMetadataReadingVisitor(classLoader);
                                                                                                            --> this.annotationMetadata = visitor;
                                                                                                            --> this.classMetadata = visitor;
                                                                                                            --> this.resource = resource;

                                                                                                    --> if (isCandidateComponent(metadataReader))
                                                                                                            //进行类型过滤
                                                                                                        --> for (TypeFilter tf : this.excludeFilters) //com.liang.BootstrapApplication,Launcher$AppClassLoader,org.springframework.beans.factory.support.DefaultListableBeanFactory@5ab9b447: defining beans [org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.event.internalEventListenerProcessor,org.springframework.context.event.internalEventListenerFactory,bootstrapApplication,org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory]; parent: org.springframework.beans.factory.support.DefaultListableBeanFactory@5a18cd76
                                                                                                        --> for (TypeFilter tf : this.includeFilters) //interface org.springframework.stereotype.Component,interface javax.annotation.ManagedBean

                                                                                                            // 进到这一步的类是
                                                                                                            // file [/Users/liang/workspace/ideaWorkspace/tut/feign/liang-openfeign/target/classes/com/liang/config/FeignRequestMappingConfiguration.class]
                                                                                                            // file [/Users/liang/workspace/ideaWorkspace/tut/feign/liang-openfeign/target/classes/com/liang/controller/TestController.class]

                                                                                                            //这两个类上面@Component注解
                                                                                                        --> ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);
                                                                                                        --> sbd.setResource(resource);
                                                                                                        --> sbd.setSource(resource);
                                                                                                        --> if (isCandidateComponent(sbd))
                                                                                                            --> candidates.add(sbd);

                                                                                                --> return candidates;

                                                                                        //处理被Component标记的类,将标记的类变成BeanDefinition加入到容器中
                                                                                    --> for (BeanDefinition candidate : candidates)
                                                                                        --> ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
                                                                                            --> org.springframework.context.annotation.AnnotationScopeMetadataResolver.resolveScopeMetadata
                                                                                                --> ScopeMetadata metadata = new ScopeMetadata();
                                                                                                --> if (definition instanceof AnnotatedBeanDefinition)
                                                                                                    --> AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition;
                                                                                                    --> AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(annDef.getMetadata(), this.scopeAnnotationType);
                                                                                                    --> return metadata;

                                                                                        --> candidate.setScope(scopeMetadata.getScopeName()); //singleton
                                                                                        --> String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); //feignRequestMappingConfiguration
                                                                                        --> if (candidate instanceof AbstractBeanDefinition)
                                                                                            --> postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
                                                                                                --> org.springframework.context.annotation.ClassPathBeanDefinitionScanner.postProcessBeanDefinition
                                                                                                    --> beanDefinition.applyDefaults(this.beanDefinitionDefaults);
                                                                                                        --> setLazyInit(defaults.isLazyInit()); //false
                                                                                                            setAutowireMode(defaults.getAutowireMode()); // 0
                                                                                                            setDependencyCheck(defaults.getDependencyCheck()); //0
                                                                                                            setInitMethodName(defaults.getInitMethodName()); //null
                                                                                                            setEnforceInitMethod(false);
                                                                                                            setDestroyMethodName(defaults.getDestroyMethodName()); //null
                                                                                                            setEnforceDestroyMethod(false);

                                                                                        --> if (candidate instanceof AnnotatedBeanDefinition)
                                                                                                //处理一下通用的注解，@Lazy，@Primary这种注解
                                                                                            --> AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);

                                                                                        --> if (checkCandidate(beanName, candidate))
                                                                                            --> BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
                                                                                                --> this.beanDefinition = beanDefinition;
                                                                                                    this.beanName = beanName;
                                                                                                    this.aliases = aliases;
                                                                                            --> definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
                                                                                                --> return definition;

                                                                                            --> beanDefinitions.add(definitionHolder);
                                                                                            --> registerBeanDefinition(definitionHolder, this.registry);
                                                                                                --> BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);
                                                                                                        // Register bean definition under primary name.
                                                                                                    --> String beanName = definitionHolder.getBeanName();
                                                                                                    --> registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());


                                                                                    --> return beanDefinitions; //Bean definition with name 'feignRequestMappingConfiguration': Generic bean: class [com.liang.config.FeignRequestMappingConfiguration]; scope=singleton; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in file [/Users/liang/workspace/ideaWorkspace/tut/feign/liang-openfeign/target/classes/com/liang/config/FeignRequestMappingConfiguration.class]
                                                                                                                //Bean definition with name 'testController': Generic bean: class [com.liang.controller.TestController]; scope=singleton; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in file [/Users/liang/workspace/ideaWorkspace/tut/feign/liang-openfeign/target/classes/com/liang/controller/TestController.class]


                                                                        --> for (BeanDefinitionHolder holder : scannedBeanDefinitions)
                                                                            --> BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();
                                                                            --> bdCand = holder.getBeanDefinition();

                                                                                //判断如果被@Configuration注解了，就给设置个key为configurationClass的属性
                                                                            --> if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory))

                                                                                    // com.liang.config.FeignRequestMappingConfiguration进来了
                                                                                --> parse(bdCand.getBeanClassName(), holder.getBeanName());
                                                                                    --> MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className);
                                                                                            //classpath:com/liang/config/FeignRequestMappingConfiguration.class
                                                                                        --> String resourcePath = ResourceLoader.CLASSPATH_URL_PREFIX + ClassUtils.convertClassNameToResourcePath(className) + ClassUtils.CLASS_FILE_SUFFIX;
                                                                                        --> Resource resource = this.resourceLoader.getResource(resourcePath);
                                                                                        --> return getMetadataReader(resource);
                                                                                            --> org.springframework.boot.type.classreading.ConcurrentReferenceCachingMetadataReaderFactory.getMetadataReader
                                                                                                --> MetadataReader metadataReader = createMetadataReader(resource);
                                                                                                    --> return super.getMetadataReader(resource);
                                                                                                        --> org.springframework.core.type.classreading.SimpleMetadataReaderFactory.getMetadataReader(org.springframework.core.io.Resource)
                                                                                                            --> return new SimpleMetadataReader(resource, this.resourceLoader.getClassLoader());
                                                                                                --> return metadataReader;

                                                                                    --> processConfigurationClass(new ConfigurationClass(reader, beanName));
                                                                                        --> org.springframework.context.annotation.ConfigurationClassParser.processConfigurationClass
                                                                                            --> SourceClass sourceClass = asSourceClass(configClass);
                                                                                                --> AnnotationMetadata metadata = configurationClass.getMetadata();
                                                                                                --> return asSourceClass(metadata.getClassName());
                                                                                                    --> return new SourceClass(this.metadataReaderFactory.getMetadataReader(className));
                                                                                                        --> this.source = source;
                                                                                                        --> this.metadata = ((MetadataReader) source).getAnnotationMetadata();

                                                                                                //这个方法就是处理一下被@Configuration注解标记的类上面有没有@Import注解
                                                                                                //Apply processing and build a complete {@link ConfigurationClass} by reading the
                                                                                                //annotations, members and methods from the source class. This method can be called
                                                                                                //multiple times as relevant sources are discovered.
                                                                                            --> sourceClass = doProcessConfigurationClass(configClass, sourceClass);
                                                                                                --> if (configClass.getMetadata().isAnnotated(Component.class.getName()))
                                                                                                    --> processMemberClasses(configClass, sourceClass);

                                                                                                --> Set<SourceClass> imports = getImports(sourceClass)
                                                                                                    --> Set<SourceClass> imports = new LinkedHashSet<>();
                                                                                                    --> Set<SourceClass> visited = new LinkedHashSet<>();
                                                                                                    --> collectImports(sourceClass, imports, visited);
                                                                                                            //递归 不导入@Import的内容
                                                                                                        --> if (!annName.startsWith("java") && !annName.equals(Import.class.getName()))
                                                                                                            -->  collectImports(annotation, imports, visited);

                                                                                                    --> return imports;

                                                                                                    //FeignRequestMappingConfiguration这个类和TestController都没有@Import注解，所以直接返回了
                                                                                                --> processImports(configClass, sourceClass,imports , true);
                                                                                                    --> return

                                                                                                    //处理配置类中被@Bean标记的方法，生成BeanMethod,然后添加到集合中
                                                                                                --> Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);
                                                                                                    --> configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));

                                                                                            --> this.configurationClasses.put(configClass, configClass);

                                                                    //上面处理完了启动类上面标注的@SpringBootApplication注解，@SpringBootApplication注解里面有@ComponentScan，然后对包下面的所有被@Component注解标注的类进行扫描
                                                                    //接下来处理启动类上@Import标注的注解
                                                                    //启动类上有三个@Import注解，
                                                                    //一个是org.springframework.boot.autoconfigure.EnableAutoConfiguration的org.springframework.boot.autoconfigure.AutoConfigurationPackage
                                                                    //一个是org.springframework.boot.autoconfigure.AutoConfigurationImportSelector，
                                                                    //一个是org.springframework.cloud.openfeign.FeignClientsRegistrar
                                                                --> Set<SourceClass> imports = getImports(sourceClass)
                                                                    --> Set<SourceClass> imports = new LinkedHashSet<>();
                                                                    --> Set<SourceClass> visited = new LinkedHashSet<>();

                                                                        //org.springframework.boot.autoconfigure.SpringBootApplication
                                                                        //org.springframework.cloud.openfeign.EnableFeignClients
                                                                    --> collectImports(sourceClass, imports, visited);
                                                                        --> Collection<SourceClass> co = sourceClass.getAnnotationAttributes(Import.class.getName(), "value")
                                                                            --> Map<String, Object> annotationAttributes = this.metadata.getAnnotationAttributes(annType, true);
                                                                            --> String[] classNames = (String[]) annotationAttributes.get(attribute);
                                                                            --> Set<SourceClass> result = new LinkedHashSet<>();
                                                                            --> result.add(getRelated(className));
                                                                            --> return result;

                                                                        --> imports.addAll(co);

                                                                        //最后添加了三个值
                                                                        //[org.springframework.boot.autoconfigure.AutoConfigurationPackages$Registrar
                                                                        //org.springframework.boot.autoconfigure.AutoConfigurationImportSelector
                                                                        //org.springframework.cloud.openfeign.FeignClientsRegistrar]
                                                                    --> return imports;

                                                                --> processImports(configClass, sourceClass, imports, true);
                                                                    --> for (SourceClass candidate : imports)
                                                                        --> org.springframework.boot.autoconfigure.AutoConfigurationPackages$Registrar
                                                                            --> if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class))
                                                                                --> Class<?> candidateClass = candidate.loadClass();
                                                                                --> ImportBeanDefinitionRegistrar registrar = BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);
                                                                                --> ParserStrategyUtils.invokeAwareMethods(registrar, this.environment, this.resourceLoader, this.registry);

                                                                                --> configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
                                                                                    --> this.importBeanDefinitionRegistrars.put(registrar, importingClassMetadata);


                                                                        --> org.springframework.boot.autoconfigure.AutoConfigurationImportSelector
                                                                            --> if (candidate.isAssignable(ImportSelector.class))
                                                                                --> Class<?> candidateClass = candidate.loadClass();
                                                                                --> ImportSelector selector = BeanUtils.instantiateClass(candidateClass, ImportSelector.class);
                                                                                --> ParserStrategyUtils.invokeAwareMethods(selector, this.environment, this.resourceLoader, this.registry);
                                                                                    --> if (parserStrategyBean instanceof Aware)
                                                                                        --> ((BeanClassLoaderAware) parserStrategyBean).setBeanClassLoader(classLoader);
                                                                                        --> ((BeanFactoryAware) parserStrategyBean).setBeanFactory((BeanFactory) registry);
                                                                                        --> ((EnvironmentAware) parserStrategyBean).setEnvironment(environment);
                                                                                        --> ((ResourceLoaderAware) parserStrategyBean).setResourceLoader(resourceLoader);
                                                                                --> if (selector instanceof DeferredImportSelector)
                                                                                    --> this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector);
                                                                                        --> org.springframework.context.annotation.ConfigurationClassParser.DeferredImportSelectorHandler.handle
                                                                                            --> DeferredImportSelectorHolder holder = new DeferredImportSelectorHolder(configClass, importSelector);
                                                                                            --> this.deferredImportSelectors.add(holder);

                                                                        --> org.springframework.cloud.openfeign.FeignClientsRegistrar
                                                                            --> if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class))
                                                                                --> Class<?> candidateClass = candidate.loadClass();
                                                                                --> ImportBeanDefinitionRegistrar registrar = BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);
                                                                                --> ParserStrategyUtils.invokeAwareMethods(registrar, this.environment, this.resourceLoader, this.registry);
                                                                                    --> if (parserStrategyBean instanceof Aware)
                                                                                        --> ((EnvironmentAware) parserStrategyBean).setEnvironment(environment);
                                                                                        --> ((ResourceLoaderAware) parserStrategyBean).setResourceLoader(resourceLoader);

                                                                                --> configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
                                                                                    --> this.importBeanDefinitionRegistrars.put(registrar, importingClassMetadata);


                                                                --> AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);

                                                                --> Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);

                                                                --> processInterfaces(configClass, sourceClass);

                                                        --> this.configurationClasses.put(configClass, configClass);

                                                    //开始处理导入的过程，这里导入的都是AutoConfiguration的内容，就是springboot默认的一些配置，
                                                    //是从spring-boot-autoconfiguration项目中的meta-inf/spring.factories文件中读取的
                                                    //在处理这些类时候还会扫描上面加了@ComponentScans，@ImportResource等这些注解，递归去加载
                                                --> this.deferredImportSelectorHandler.process();
                                                    --> org.springframework.context.annotation.ConfigurationClassParser.DeferredImportSelectorHandler.process
                                                        --> List<DeferredImportSelectorHolder> deferredImports = this.deferredImportSelectors; // 现在里面有一个：AutoConfigurationImportSelector
                                                        --> DeferredImportSelectorGroupingHandler handler = new DeferredImportSelectorGroupingHandler();
                                                        --> deferredImports.forEach(handler::register);
                                                            --> Class<? extends Group> group = deferredImport.getImportSelector().getImportGroup();
                                                            --> DeferredImportSelectorGrouping grouping = this.groupings.computeIfAbsent(
                                                                					(group != null ? group : deferredImport),
                                                                					key -> new DeferredImportSelectorGrouping(createGroup(group)));
                                                            --> this.configurationClasses.put(deferredImport.getConfigurationClass().getMetadata(),
                                                                					deferredImport.getConfigurationClass());

                                                            //处理默认的配置类
                                                        --> handler.processGroupImports();
                                                            --> for (DeferredImportSelectorGrouping grouping : this.groupings.values()) //"class org.springframework.boot.autoconfigure.AutoConfigurationImportSelector$AutoConfigurationGroup" ->
                                                                --> ConfigurationClass configurationClass = this.configurationClasses.get(entry.getMetadata()); //ConfigurationClass: beanName 'bootstrapApplication', com.liang.BootstrapApplication
                                                                --> processImports(configurationClass, asSourceClass(configurationClass),asSourceClasses(entry.getImportClassName()), false);
                                                                    --> org.springframework.context.annotation.ConfigurationClassParser.processImports
                                                                        --> processConfigurationClass(candidate.asConfigClass(configClass));


                                                //验证一下类是不是被@Configuration标记
                                            --> parser.validate();
                                            --> this.reader = new ConfigurationClassBeanDefinitionReader(
                                                						registry, this.sourceExtractor, this.resourceLoader, this.environment,
                                                						this.importBeanNameGenerator, parser.getImportRegistry());

                                                // 里面有74个 ,前三个就是自定义的被@Configuration注解的
                                            --> this.reader.loadBeanDefinitions(configClasses);
                                                --> org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitions
                                                        //这里就看前三个，后面跳过
                                                    --> for (ConfigurationClass configClass : configurationModel)
                                                        --> feignRequestMappingConfiguration
                                                            --> loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);
                                                                --> for (BeanMethod beanMethod : configClass.getBeanMethods()) //[BeanMethod:name=feignWebRegistrations,declaringClass=com.liang.config.FeignRequestMappingConfiguration]
                                                                    --> loadBeanDefinitionsForBeanMethod(beanMethod);
                                                                        --> org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitionsForBeanMethod
                                                                            --> ConfigurationClass configClass = beanMethod.getConfigurationClass();
                                                                            --> MethodMetadata metadata = beanMethod.getMetadata();
                                                                            --> String methodName = metadata.getMethodName(); //feignWebRegistrations
                                                                            --> AnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);
                                                                                // Consider name and any aliases
                                                                            --> List<String> names = new ArrayList<>(Arrays.asList(bean.getStringArray("name")));
                                                                            --> ConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata);
                                                                            --> beanDef.setResource(configClass.getResource());
                                                                            --> beanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));

                                                                            --> beanDef.setFactoryBeanName(configClass.getBeanName());
                                                                            --> beanDef.setUniqueFactoryMethodName(methodName);
                                                                            --> beanDef.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);
                                                                            --> beanDef.setAttribute(org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);
                                                                            --> AnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);
                                                                            --> ScopedProxyMode proxyMode = ScopedProxyMode.NO;
                                                                            --> AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class);
                                                                            --> BeanDefinition beanDefToRegister = beanDef;

                                                                                //把@Bean的方法也变成了BeanDefinition，注册到容器里面
                                                                            --> this.registry.registerBeanDefinition(beanName, beanDefToRegister);

                                                                --> loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());

                                                                --> loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());

                                                        --> testController
                                                            --> loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);
                                                                --> loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());

                                                                --> loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());

                                                            //重点在这里，里面会处理@EnableFeignClients
                                                        --> bootstrapApplication
                                                            --> loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);
                                                                --> loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());

                                                                --> loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars()); // FeignClientsRegistrar,AutoConfigurationPackages#Registrar
                                                                    --> registrars.forEach((registrar, metadata) -> registrar.registerBeanDefinitions(metadata, this.registry));
                                                                        --> org.springframework.cloud.openfeign.FeignClientsRegistrar.registerBeanDefinitions
                                                                                //这一步是注册BeanDefinition
                                                                            --> registerDefaultConfiguration(metadata, registry);

                                                                                    //获取了@EnableFeignClients里面的属性
                                                                                --> Map<String, Object> defaultAttrs = metadata.getAnnotationAttributes(EnableFeignClients.class.getName(), true);

                                                                                    //系统启动时候有org.springframework.cloud.openfeign.FeignClientsConfiguration，上面标注了@Configuration，里面初始化了feignClient的一些bean
                                                                                    //在meta-inf/spring.factories里面配置了org.springframework.cloud.openfeign.FeignAutoConfiguration，也会初始化一些bean
                                                                                --> if (defaultAttrs != null && defaultAttrs.containsKey("defaultConfiguration"))
                                                                                    --> String name = "default." + metadata.getClassName(); //default.com.liang.BootstrapApplication
                                                                                    --> registerClientConfiguration(registry, name, defaultAttrs.get("defaultConfiguration"));
                                                                                        --> BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(FeignClientSpecification.class);
                                                                                            --> org.springframework.beans.factory.support.BeanDefinitionBuilder.genericBeanDefinition(java.lang.Class<?>)
                                                                                                --> BeanDefinitionBuilder builder = new BeanDefinitionBuilder(new GenericBeanDefinition());
                                                                                                --> builder.beanDefinition.setBeanClass(beanClass);
                                                                                                --> return builder;

                                                                                        --> builder.addConstructorArgValue(name);   //default.com.liang.BootstrapApplication
                                                                                        --> builder.addConstructorArgValue(configuration); //{}
                                                                                        --> registry.registerBeanDefinition(
                                                                                                name + "." + FeignClientSpecification.class.getSimpleName(),
                                                                                                builder.getBeanDefinition());
                                                                                            --> org.springframework.beans.factory.support.DefaultListableBeanFactory.registerBeanDefinition(String beanName, BeanDefinition beanDefinition) // beanName = default.com.liang.BootstrapApplication.FeignClientSpecification
                                                                                                --> this.beanDefinitionMap.put(beanName, beanDefinition);
                                                                                                --> List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
                                                                                                --> updatedDefinitions.addAll(this.beanDefinitionNames);
                                                                                                --> updatedDefinitions.add(beanName);
                                                                                                --> this.beanDefinitionNames = updatedDefinitions;
                                                                                                --> this.frozenBeanDefinitionNames = null;

                                                                            --> registerFeignClients(metadata, registry);
                                                                                --> ClassPathScanningCandidateComponentProvider scanner = getScanner();
                                                                                    --> return new ClassPathScanningCandidateComponentProvider(boolean useDefaultFilters, Environment environment)
                                                                                        --> this.resourcePattern = "**/*.class";
                                                                                        --> this.includeFilters = new LinkedList();
                                                                                        --> this.excludeFilters = new LinkedList();
                                                                                        --> this.registerDefaultFilters();
                                                                                        --> this.setEnvironment(environment);
                                                                                        --> this.setResourceLoader((ResourceLoader)null);

                                                                                --> scanner.setResourceLoader(this.resourceLoader);
                                                                                --> Set<String> basePackages;
                                                                                --> Map<String, Object> attrs = metadata.getAnnotationAttributes(EnableFeignClients.class.getName());
                                                                                    //注册一个FeignClient的过滤器，扫描class的时候只扫描被@FeignClient的class
                                                                                --> AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter(FeignClient.class);
                                                                                --> final Class<?>[] clients = attrs == null ? null : (Class<?>[]) attrs.get("clients");
                                                                                --> scanner.addIncludeFilter(annotationTypeFilter);
                                                                                --> basePackages = getBasePackages(metadata); // com.liang

                                                                                --> for (String basePackage : basePackages)
                                                                                    --> Set<BeanDefinition> candidateComponents = scanner.findCandidateComponents(basePackage);
                                                                                        --> org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents
                                                                                            --> return scanCandidateComponents(basePackage);
                                                                                                --> 扫描class文件和之前的一样，只不过中间加了层过滤，只找出了标记@FeignClient的class

                                                                                        //进行包扫描，然后注册成为AnnotatedBeanDefinition
                                                                                    --> for (BeanDefinition candidateComponent : candidateComponents)
                                                                                        --> if (candidateComponent instanceof AnnotatedBeanDefinition)
                                                                                            --> AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;
                                                                                            --> AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();
                                                                                            --> Map<String, Object> attributes = annotationMetadata.getAnnotationAttributes(FeignClient.class.getCanonicalName()); // {"name" -> "github-server","url" -> "https://api.github.com", "value" -> "github-server","fallback" -> "void","primary" -> "true","decode404" -> "false","fallbackFactory" -> "void"}
                                                                                            --> String name = getClientName(attributes); // github-server
                                                                                            --> registerClientConfiguration(registry, name, attributes.get("configuration")); // name=github-server
                                                                                                --> BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(FeignClientSpecification.class);
                                                                                                    --> org.springframework.beans.factory.support.BeanDefinitionBuilder.genericBeanDefinition(java.lang.Class<?>)
                                                                                                        --> BeanDefinitionBuilder builder = new BeanDefinitionBuilder(new GenericBeanDefinition());
                                                                                                        --> builder.beanDefinition.setBeanClass(beanClass);
                                                                                                        --> return builder;

                                                                                                --> builder.addConstructorArgValue(name);   //github-server
                                                                                                --> builder.addConstructorArgValue(configuration); //{}
                                                                                                --> registry.registerBeanDefinition(name + "." + FeignClientSpecification.class.getSimpleName(),builder.getBeanDefinition());
                                                                                                    --> org.springframework.beans.factory.support.DefaultListableBeanFactory.registerBeanDefinition(String beanName, BeanDefinition beanDefinition) // beanName = github-server.FeignClientSpecification
                                                                                                        --> this.beanDefinitionMap.put(beanName, beanDefinition);
                                                                                                        --> List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
                                                                                                        --> updatedDefinitions.addAll(this.beanDefinitionNames);
                                                                                                        --> updatedDefinitions.add(beanName);
                                                                                                        --> this.beanDefinitionNames = updatedDefinitions;
                                                                                                        --> this.frozenBeanDefinitionNames = null;

                                                                                            --> registerFeignClient(registry, annotationMetadata, attributes);
                                                                                                --> String className = annotationMetadata.getClassName(); // com.liang.client.Github

                                                                                                    //这里调用了FactoryBean,然后为BeanDefinitionBuilder付属性
                                                                                                --> BeanDefinitionBuilder definition = BeanDefinitionBuilder.genericBeanDefinition(FeignClientFactoryBean.class); //beanClass = class org.springframework.cloud.openfeign.FeignClientFactoryBean
                                                                                                    --> BeanDefinitionBuilder builder = new BeanDefinitionBuilder(new GenericBeanDefinition());
                                                                                                    --> builder.beanDefinition.setBeanClass(beanClass);
                                                                                                    --> return builder;

                                                                                                --> definition.addPropertyValue("url", getUrl(attributes));
                                                                                                --> definition.addPropertyValue("path", getPath(attributes));
                                                                                                --> String name = getName(attributes); //github-server
                                                                                                --> definition.addPropertyValue("name", name);
                                                                                                --> String contextId = getContextId(attributes);
                                                                                                    --> String contextId = (String) attributes.get("contextId");
                                                                                                    --> return getName(attributes);
                                                                                                        --> String name = (String) attributes.get("serviceId");
                                                                                                        --> name = (String) attributes.get("name");
                                                                                                        --> name = resolve(name);
                                                                                                            --> return this.environment.resolvePlaceholders(value); //github-server
                                                                                                        --> return getName(name);
                                                                                                            --> String host = null;
                                                                                                            --> if (!name.startsWith("http://") && !name.startsWith("https://"))
                                                                                                                --> url = "http://" + name;  // http://github-server
                                                                                                            --> host = new URI(url).getHost(); // github-server
                                                                                                            --> return name; // github-server

                                                                                                --> definition.addPropertyValue("contextId", contextId);
                                                                                                --> definition.addPropertyValue("type", className); //com.liang.client.Github
                                                                                                --> definition.addPropertyValue("decode404", attributes.get("decode404"));
                                                                                                --> definition.addPropertyValue("fallback", attributes.get("fallback"));
                                                                                                --> definition.addPropertyValue("fallbackFactory", attributes.get("fallbackFactory"));
                                                                                                --> definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);

                                                                                                --> String alias = contextId + "FeignClient";  // github-serverFeignClient
                                                                                                --> AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();

                                                                                                --> boolean primary = (Boolean) attributes.get("primary"); // has a default, won't be
                                                                                                                                                        // null

                                                                                                --> beanDefinition.setPrimary(primary);

                                                                                                --> String qualifier = getQualifier(attributes);


                                                                                                --> BeanDefinitionHolder holder = new BeanDefinitionHolder(beanDefinition, className, ew String[] { alias });
                                                                                                    --> this.beanDefinition = beanDefinition; //Generic bean: class [org.springframework.cloud.openfeign.FeignClientFactoryBean]; scope=; abstract=false; lazyInit=false; autowireMode=2; dependencyCheck=0; autowireCandidate=true; primary=true; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null
                                                                                                        this.beanName = beanName; // com.liang.client.Github
                                                                                                        this.aliases = aliases; //github-serverFeignClient

                                                                                                --> BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);
                                                                                                    --> String beanName = definitionHolder.getBeanName(); //com.liang.client.Github
                                                                                                    --> registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
                                                                                                        --> this.beanDefinitionMap.put(beanName, beanDefinition);

                                                                                                    --> String[] aliases = definitionHolder.getAliases();
                                                                                                    --> registry.registerAlias(beanName, alias);
                                                                                                        --> this.aliasMap.put(alias, name);




                                            --> alreadyParsed.addAll(configClasses);

                                            --> String[] newCandidateNames = registry.getBeanDefinitionNames();

                                            --> candidateNames = newCandidateNames; // 里面有182个

                                            --> if (sbr != null && !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME))
                                                    // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
                                                --> sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry()); // ConfigurationClassPostProcessor.class.getName() + ".importRegistry";

                                    //这一步把扫描的类中所有实现了org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor这个接口的类放到集合中，
                                --> postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
                                    --> return doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit);

                                --> for (String ppName : postProcessorNames)
                                    --> currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));

                                    //循环调用实现类中的方法
                                --> invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
                                    --> for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors)
                                        --> postProcessor.postProcessBeanDefinitionRegistry(registry);

                                    // 获取所有实现了BeanFactoryPostProcessor接口得类
                                    //先处理标记了PriorityOrdered的类，然后执行Ordered的类，然后才是别的
                                --> String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);
                                --> nonOrderedPostProcessorNames.add(ppName);

                                --> nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));

                                --> invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);

                                // Instantiate all remaining (non-lazy-init) singletons.
                                //这里比较特殊，会处理@Bean,这里里面就包含了org.springframework.cloud.openfeign.FeignAutoConfiguration
                                // 和org.springframework.cloud.openfeign.FeignClientsConfiguration这样的配置类，会生生对应的bean，里面会调用feign的一些初始化内容
                                // 里面会有类似直接用feign的那种Feign.builder()之类的代码
                            --> finishBeanFactoryInitialization(beanFactory);
                                --> beanFactory.preInstantiateSingletons();
                                    --> List<String> beanNames = new ArrayList<>(this.beanDefinitionNames);
                                    --> for (String beanName : beanNames)
                                            //如果是factoryBean，就通过factoryBean生成bean
                                        --> if (isFactoryBean(beanName))
                                            -->
                                        --> else
                                                //如果不是factoryBean，就直接生成bean
                                            --> getBean(beanName);
                                                --> return doGetBean(name, null, null, false);
                                                    --> final String beanName = transformedBeanName(name);
                                                    --> Object sharedInstance = getSingleton(beanName);
                                                        //会对bean进行初始化
                                                    --> bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);

            --> afterRefresh(context, applicationArguments);
            --> listeners.started(context);
            --> callRunners(context, applicationArguments);
            --> listeners.running(context);
            --> return context; //org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@5987e932, started on Fri Sep 06 10:23:54 CST 2019, parent: org.springframework.context.annotation.AnnotationConfigApplicationContext@34f6515b


        //springboot启动过程中会调用factoryBean的方法，这一步就会调用到FeignClientFacotryBean
    --> org.springframework.context.support.AbstractApplicationContext.refresh()
        --> finishBeanFactoryInitialization(beanFactory);
            --> org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization
                --> beanFactory.preInstantiateSingletons();
                    --> org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons
                        --> getBean(beanName);
                            --> org.springframework.beans.factory.support.AbstractBeanFactory.getBean(java.lang.String)
                                --> return doGetBean(name, null, null, false);
                                    --> return createBean(beanName, mbd, args);
                                        --> org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(java.lang.String, org.springframework.beans.factory.ObjectFactory<?>)
                                            --> return singletonObject = singletonFactory.getObject();
                                                --> org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean
                                                    --> return createBean(beanName, mbd, args);
                                                        --> org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])
                                                            --> Object beanInstance = doCreateBean(beanName, mbdToUse, args);
                                                                --> populateBean(beanName, mbd, instanceWrapper);
                                                                    --> InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
                                                                    --> PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
                                                                        --> org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#postProcessProperties
                                                                            --> InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);
                                                                            --> metadata.inject(bean, beanName, pvs);
                                                                                --> org.springframework.beans.factory.annotation.InjectionMetadata.inject
                                                                                    --> element.inject(target, beanName, pvs);
                                                                                        --> org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement.inject
                                                                                            --> value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);
                                                                                                --> org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency
                                                                                                    --> result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);
                                                                                                        --> Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);
                                                                                                            --> addCandidateEntry(result, candidate, descriptor, requiredType);
                                                                                                                --> Object beanInstance = descriptor.resolveCandidate(candidateName, requiredType, this);
                                                                                                                    --> return beanFactory.getBean(beanName);
                                                                                                                        --> org.springframework.beans.factory.support.AbstractBeanFactory.getBean(java.lang.String)
                                                                                                                            --> return doGetBean(name, null, null, false);
                                                                                                                                --> bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
                                                                                                                                    --> return super.getObjectForBeanInstance(beanInstance, name, beanName, mbd);
                                                                                                                                        --> org.springframework.beans.factory.support.AbstractBeanFactory.getObjectForBeanInstance
                                                                                                                                            --> object = getObjectFromFactoryBean(factory, beanName, !synthetic);
                                                                                                                                                --> org.springframework.beans.factory.support.FactoryBeanRegistrySupport.getObjectFromFactoryBean
                                                                                                                                                    --> object = doGetObjectFromFactoryBean(factory, beanName);
                                                                                                                                                        --> object = factory.getObject();
                                                                                                                                                            --> org.springframework.cloud.openfeign.FeignClientFactoryBean.getObject()
                                                                                                                                                                --> return getTarget();
                                                                                                                                            --> return object;
                                                            --> return beanInstance;

        // spring会调用FeignClientFactoryBean的getObject方法
        // 一个容器中创建多个feignContext的部分
    --> org.springframework.cloud.openfeign.FeignClientFactoryBean.getObject
        --> return getTarget();
            --> FeignContext context = this.applicationContext.getBean(FeignContext.class);
            --> Feign.Builder builder = feign(context);
                --> FeignLoggerFactory loggerFactory = get(context, FeignLoggerFactory.class);
                    --> T instance = context.getInstance(this.contextId, type); //contextId = github-server; type = interface org.springframework.cloud.openfeign.FeignLoggerFactory
                        --> AnnotationConfigApplicationContext context = getContext(name); //github-server
                            --> org.springframework.cloud.context.named.NamedContextFactory.getContext(String name)

                                    //在这个地方，通过名字获取feignContext，如果没有就创建一个feignContext，所以当项目启动时候回出现很多个feignContext
                                --> if (!this.contexts.containsKey(name))
                                    --> his.contexts.put(name, createContext(name));
                                        --> AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
                                        --> context.register(PropertyPlaceholderAutoConfiguration.class,this.defaultConfigType);
                                        --> context.getEnvironment().getPropertySources().addFirst(new MapPropertySource(
                                            				this.propertySourceName,
                                            				Collections.<String, Object>singletonMap(this.propertyName, name)));
                                        --> if (this.parent != null)
                                            --> context.setParent(this.parent);
                                            --> context.setClassLoader(this.parent.getClassLoader());
                                        --> context.setDisplayName(generateDisplayName(name));
                                        --> context.refresh();
                                        --> return context;

                        --> return context.getBean(type);

                    --> return instance;
                --> Logger logger = loggerFactory.create(this.type);
                --> // @formatter:off
                --> Feign.Builder builder = get(context, Feign.Builder.class)
                        // required values
                        .logger(logger)
                        .encoder(get(context, Encoder.class))
                        .decoder(get(context, Decoder.class))
                        .contract(get(context, Contract.class));
                    // @formatter:on

                --> configureFeign(context, builder);
                    --> FeignClientProperties properties = this.applicationContext.getBean(FeignClientProperties.class);
                    --> if (properties.isDefaultToProperties())
                        --> configureUsingConfiguration(context, builder);
                            --> Logger.Level level = getOptional(context, Logger.Level.class);
                            --> builder.logLevel(level);
                            --> Retryer retryer = getOptional(context, Retryer.class);
                            --> builder.retryer(retryer);
                            --> ErrorDecoder errorDecoder = getOptional(context, ErrorDecoder.class);
                            --> builder.errorDecoder(errorDecoder);
                            --> Request.Options options = getOptional(context, Request.Options.class);
                            --> builder.options(options);
                            --> Map<String, RequestInterceptor> requestInterceptors = context.getInstances(this.contextId, RequestInterceptor.class);
                            --> builder.requestInterceptors(requestInterceptors.values());
                            --> QueryMapEncoder queryMapEncoder = getOptional(context, QueryMapEncoder.class);
                            --> builder.queryMapEncoder(queryMapEncoder);
                            --> builder.decode404();

                        --> configureUsingProperties(properties.getConfig().get(properties.getDefaultConfig()),builder);

                        --> configureUsingProperties(properties.getConfig().get(this.contextId),builder);

                --> return builder;

            --> String url = this.url + cleanPath();
            --> Client client = getOptional(context, Client.class);
            --> builder.client(client);

            --> Targeter targeter = get(context, Targeter.class);

                //这里开启了hystrix，所以调用的是org.springframework.cloud.openfeign.HystrixTargeter,不开启的话调用org.springframework.cloud.openfeign.DefaultTargeter
            --> return (T) targeter.target(this, builder, context,new HardCodedTarget<>(this.type, this.name, url));
                --> org.springframework.cloud.openfeign.HystrixTargeter.target
                    --> if (!(feign instanceof feign.hystrix.HystrixFeign.Builder))
                        --> return feign.target(target);
                            --> feign.Feign.Builder.target(feign.Target<T>)
                                --> return build().newInstance(target);
                                    --> .
                                        .
                                        .
                                        之后就进入到feign-core里面了，生成代理对象的那里









    --> List<Contributor> contributors = github.contributors("OpenFeign", "feign");
            //2. 执行目标接口方法带来具体实现（FeignInvocationHandler）
        --> feign.ReflectiveFeign.FeignInvocationHandler.invoke(Object proxy, Method method, Object[] args)
                //在此我们可以看出目标函数除了equals，hashCode，toString方法外都会调用this.dispatch.get(method)).invoke(args)
                //dispatch是目标函数代理类集合，目标接口中每个函数都会对应有一个MethodHandler类，至于怎么得到的有兴趣可以查看源码
            --> return dispatch.get(method).invoke(args); // method = public abstract java.util.List com.liang.feign.GitHub.contributors(java.lang.String,java.lang.String);args=["OpenFeign","feign"]
                --> feign.SynchronousMethodHandler.invoke(Object[] argv);
                        //1. 接口方法执行都会调用其对应的invoke方法
                    --> RequestTemplate template = buildTemplateFromArgs.create(argv);
                        --> RequestTemplate mutable = RequestTemplate.from(metadata.template())
                            --> RequestTemplate template =
                                        new RequestTemplate(requestTemplate.target, requestTemplate.fragment,
                                            requestTemplate.uriTemplate,
                                            requestTemplate.method, requestTemplate.charset,
                                            requestTemplate.body, requestTemplate.decodeSlash, requestTemplate.collectionFormat);
                                --> this.target = target;
                                    this.fragment = fragment;
                                    this.uriTemplate = uriTemplate;
                                    this.method = method;
                                    this.charset = charset;
                                    this.body = body;
                                    this.decodeSlash = decodeSlash;
                                    this.collectionFormat = (collectionFormat != null) ? collectionFormat : CollectionFormat.EXPLODED;

                            --> return template;

                        --> Map<String, Object> varBuilder = new LinkedHashMap<String, Object>();

                        --> for (Entry<Integer, Collection<String>> entry : metadata.indexToName().entrySet())
                            --> int i = entry.getKey(); // 0/1
                            --> Object value = argv[entry.getKey()]; // OpenFeign/feign
                            --> varBuilder.put(name, value); // name = owner/repo ;value = OpenFeign/feign

                        --> RequestTemplate template = resolve(argv, mutable, varBuilder);
                            --> feign.ReflectiveFeign.BuildTemplateByResolvingArgs.resolve(argv, mutable, varBuilder)
                                --> return mutable.resolve(variables);
                                    --> feign.RequestTemplate.resolve(java.util.Map<java.lang.String,?>)
                                        --> StringBuilder uri = new StringBuilder();

                                        --> RequestTemplate resolved = RequestTemplate.from(this);

                                        --> uri.append(this.uriTemplate.expand(variables));
                                            --> StringBuilder resolved = new StringBuilder();
                                            --> if (chunk instanceof Expression)
                                                --> String resolvedExpression = this.resolveExpression((Expression) chunk, variables);
                                                    --> Object value = variables.get(expression.getName()); // OpenFeign/feign
                                                    --> String expanded = expression.expand(value, this.encode.isEncodingRequired());
                                                        --> feign.template.Expressions.SimpleExpression.expand(Object variable, boolean encode) // true
                                                            --> StringBuilder expanded = new StringBuilder();
                                                            --> expanded.append((encode) ? encode(variable) : variable);
                                                            --> return expanded.toString();
                                                    --> return expanded;

                                                --> resolved.append(resolvedExpression);
                                            --> else
                                                --> resolved.append(chunk.getValue());

                                            --> return resolved.toString(); // /repos/OpenFeign/feign/contributors

                                        --> resolved.uri(uri.toString()) // /repos/OpenFeign/feign/contributors

                                        --> resolved.body(this.body.expand(variables))

                                        --> return resolved;

                        --> return template;

                    --> Options options = findOptions(argv);

                        //重试组件
                    --> Retryer retryer = this.retryer.clone();

                        //执行请求并解码
                    --> return executeAndDecode(template, options);
                            //2 构建request请求并执行和解码
                        --> feign.SynchronousMethodHandler.executeAndDecode(RequestTemplate template, Options options)
                                //1). 获取request请求
                            --> Request request = targetRequest(template);
                                    //3 组装request请求，这里同时完成了拦截器调用的逻辑
                                --> feign.SynchronousMethodHandler.targetRequest(RequestTemplate template)
                                        //获取当前请求的所有拦截器
                                    --> for (RequestInterceptor interceptor : requestInterceptors)
                                            //依次调用拦截器进行拦截操作
                                        --> interceptor.apply(template);

                                        //返回Request对象
                                    --> return target.apply(template);
                                        --> feign.Target.HardCodedTarget.apply(RequestTemplate input)
                                            --> input.target(url()) // https://api.github.com
                                            --> return input.request(); // request
                                                --> return Request.create(this.method, this.url(), this.headers(), this.requestBody()); // this.url = https://api.github.com/repos/OpenFeign/feign/contributors
                                                    --> return new Request(httpMethod, url, headers, body);
                                                        --> this.httpMethod = checkNotNull(method, "httpMethod of %s", method.name());
                                                            this.url = checkNotNull(url, "url");
                                                            this.headers = checkNotNull(headers, "headers of %s %s", method, url);
                                                            this.body = body;

                            --> Response response = client.execute(request, options);
                                --> feign.Client.Default.execute(Request request, Options options);
                                    --> HttpURLConnection connection = convertAndSend(request, options);
                                        --> final HttpURLConnection connection = (HttpURLConnection) new URL(request.url()).openConnection(); // url=https://api.github.com/repos/OpenFeign/feign/contributors; connection = sun.net.www.protocol.https.DelegateHttpsURLConnection:https://api.github.com/repos/OpenFeign/feign/contributors
                                        --> HttpsURLConnection sslCon = (HttpsURLConnection) connection;
                                        --> connection.setConnectTimeout(options.connectTimeoutMillis());
                                        --> connection.setReadTimeout(options.readTimeoutMillis());
                                        --> connection.setAllowUserInteraction(false);
                                        --> connection.setInstanceFollowRedirects(options.isFollowRedirects());
                                        --> connection.setRequestMethod(request.httpMethod().name());
                                        --> connection.addRequestProperty("Accept", "*/*");
                                        --> connection.setDoOutput(true);
                                        --> OutputStream out = connection.getOutputStream();
                                        --> out.write(request.requestBody().asBytes());

                                        --> return connection;


                                    --> return convertResponse(connection, request);
                                        --> feign.Client.Default.convertResponse(HttpURLConnection connection, Request request)
                                            --> Map<String, Collection<String>> headers = new LinkedHashMap<String, Collection<String>>();
                                            --> for (Map.Entry<String, List<String>> field : connection.getHeaderFields().entrySet())

                                                --> headers.put(field.getKey(), field.getValue()); //里面存放返回的消息头

                                            --> InputStream stream = connection.getInputStream(); // 默认调用HttpUrlConnection的方法进行数据发送，这里是收到的请求响应

                                            --> return Response.builder()
                                                          .status(status)
                                                          .reason(reason)
                                                          .headers(headers)
                                                          .request(request)
                                                          .body(stream, length)
                                                          .build();
                                                --> this.status = builder.status;
                                                    this.request = builder.request;
                                                    this.reason = builder.reason; // nullable
                                                    this.headers = (builder.headers != null) ? Collections.unmodifiableMap(caseInsensitiveCopyOf(builder.headers)) : new LinkedHashMap<>();
                                                    this.body = builder.body; // nullable

                            --> Object result = decode(response);
                                --> feign.SynchronousMethodHandler.decode(response)
                                    --> return decoder.decode(response, metadata.returnType());
                                        --> feign.gson.GsonDecoder.decode(Response response, Type type)
                                            --> Reader reader = response.body().asReader();
                                            --> return gson.fromJson(reader, type);

                            --> return result;


    --> System.out.println(contributors);